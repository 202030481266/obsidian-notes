# 轻重链剖分

所谓一图胜千言，下面即使轻重链剖分后得到的一个树，每种颜色都代表着一条轻链（蓝色，深棕色，紫色，绿色）或者重链（从根出发的棕色的那条）。

![[轻重链剖分.png]]
重构后得到的树链有一些很有用的特征：
- 所有的轻链或者重链上的dfn序号都是连续的，因此**路径问题可以转换为不同的区间操作**（区间数据结构加速），并且因为启发式的原因，每切换一次不同的链，子树大小至少增加两倍，所以最多切换$\log n$次，路径也就会被拆解为不超过$\log n$个链的部分（区间）。
- 子树上的dfn序号依然是连续的，**子树问题依然可以转换为区间操作**。
基于上面的性质，一般树链剖分常用来处理树上路径和子树的修改、查询问题，而且通常来说都要转换为区间的维护问题，使用上线段树等等RMQ强力的数据结构。
# 构建轻重链

树链剖分的实现代码非常简单，使用两个dfs递归遍历即可，注意第二个dfs中一定要先保证遍历重儿子，下面是具体的实现代码：

```cpp
int dep[maxn], fa[maxn], dfn[maxn], ids[maxn], siz[maxn];
int son[maxn], top[maxn], tot;
vector<int> g[maxn];

void dfs1(int u, int f) {
    dep[u] = dep[f] + 1;
    siz[u] = 1;
    fa[u] = f;
    for (int v : g[u]) {
        if (v != f) {
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[v] > siz[son[u]]) son[u] = v;
        }
    }
}
void dfs2(int u, int f) {
    dfn[u] = ++tot;
    ids[tot] = u;
    top[u] = f;
    if (!son[u]) return;
    dfs2(son[u], f); 
    for (int v : g[u]) {
        if (v != son[u] && v != fa[u]) {
            dfs2(v, v);
        }
    }
}
```
# 具体应用

树链剖分常见的应用就是用来维护树上路径问题，复杂度为$\log^2 n$，常数较小，而且实现非常简单。

[轻重链剖分模板题](https://www.luogu.com.cn/problem/P3384)
## 题目描述

如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：

- `1 x y z`，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。

- `2 x y`，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。

- `3 x z`，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。

- `4 x` 表示求以 $x$ 为根节点的子树内所有节点值之和

## 输入格式

第一行包含 $4$ 个正整数 $N,M,R,P$，分别表示树的结点个数、操作个数、根节点序号和取模数（**即所有的输出结果均对此取模**）。

接下来一行包含 $N$ 个非负整数，分别依次表示各个节点上初始的数值。

接下来 $N-1$ 行每行包含两个整数 $x,y$，表示点 $x$ 和点 $y$ 之间连有一条边（保证无环且连通）。

接下来 $M$ 行每行包含若干个正整数，每行表示一个操作。

## 输出格式

输出包含若干行，分别依次表示每个操作 $2$ 或操作 $4$ 所得的结果（**对 $P$ 取模**）。

## 输入输出样例 #1

### 输入 #1

```
5 5 2 24
7 3 7 8 0 
1 2
1 5
3 1
4 1
3 4 2
3 2 2
4 5
1 5 1 3
2 1 3
```

### 输出 #1

```
2
21
```

## 说明/提示

**【数据规模】**

对于 $30\%$ 的数据： $1 \leq N \leq 10$，$1 \leq M \leq 10$；

对于 $70\%$ 的数据： $1 \leq N \leq {10}^3$，$1 \leq M \leq {10}^3$；

对于 $100\%$ 的数据： $1\le N \leq {10}^5$，$1\le M \leq {10}^5$，$1\le R\le N$，$1\le P \le 2^{30}$。所有输入的数均在 `int` 范围内。

**【样例说明】**

树的结构如下：

![](https://cdn.luogu.com.cn/upload/pic/2319.png)

各个操作如下：

![](https://cdn.luogu.com.cn/upload/pic/2320.png)

故输出应依次为 $2$ 和 $21$。
## 解决方法

首先使用树链剖分的时候，**一般来说我们都是在不断的往上跳！这是一个寻找LCA的过程，但是同时也是切换到不同的链的过程，在这个过程中本质上是在完成一些区间的遍历**。比方说更新$x$和$y$的路径上的所有的值：

```cpp
while (top[x] != top[y]) {
	if (dep[top[x]] <= dep[top[y]]) {
		update(1, 1, n, dfn[top[y]], dfn[y], z);
		y = fa[top[y]];
	}
	else {
		update(1, 1, n, dfn[top[x]], dfn[x], z);
		x = fa[top[x]];
	}
}
update(1, 1, n, min(dfn[x], dfn[y]), max(dfn[x], dfn[y]), z);
```

或者说查询$x$和$y$的路径上的所有的值的和：

```cpp
while (top[x] != top[y]) {
	if (dep[top[x]] <= dep[top[y]]) {
		ans = (ans + query(1, 1, n, dfn[top[y]], dfn[y])) % p;
		y = fa[top[y]];
	}
	else {
		ans = (ans + query(1, 1, n, dfn[top[x]], dfn[x])) % p;
		x = fa[top[x]];
	}
}
ans = (ans + query(1, 1, n, min(dfn[x], dfn[y]), max(dfn[x], dfn[y]))) % p;
```

