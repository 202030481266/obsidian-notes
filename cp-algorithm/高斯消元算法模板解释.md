
# 高斯消元算法介绍

[[高斯消元解决非方阵系统]]

# 高斯消元算法的实现与验证的重要性总结

## 1. 问题背景

下面是一个高斯消元法的实现，用于求解线性方程组。其中有一些关键的点，尤其是理解关于自由变量的处理和解的验证部分是否必要。

示例方程：

$$
\begin{cases}
x_1 + x_2 = 3 \\
2x_1 + 2x_2 = 4
\end{cases}
$$

通过此示例，我们可以看到验证步骤的作用，以及代码中一些容易令人困惑的地方。

## 2. 代码解释与重新格式化

重新格式化后的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const double eps = 1e-9; // 精度
// 高斯消元主函数，输入增广矩阵a，输出解向量ans
int Gauss(vector<vector<double>> a, vector<double> &ans)
{
    int n = (int)a.size();    // 方程数量
    int m = (int)a[0].size() - 1; // 未知数数量（减去增广列）
    
    vector<int> pos(m, -1);   // 记录每个未知数对应的主元所在行
    double det = 1;           // 行列式初始值
    int rank = 0;             // 矩阵的秩

    // 遍历列和行，进行消元
    for(int col = 0, row = 0; col < m && row < n; ++col)
    {
        // 找出当前列中绝对值最大的元素作为主元
        int mx = row;
        for(int i = row; i < n; i++) 
            if(fabs(a[i][col]) > fabs(a[mx][col])) mx = i;
        
        // 如果主元接近0，说明该列无法消元，继续处理下一列
        if(fabs(a[mx][col]) < eps)
        {
            det = 0;
            continue;
        }

        // 交换当前行与包含最大主元的行
        for(int i = col; i <= m; i++) 
            swap(a[row][i], a[mx][i]);
        
        // 如果发生行交换，调整行列式符号
        if (row != mx) det = -det;
        det *= a[row][col];
        
        pos[col] = row; // 记录主元所在的行
        
        // 消去其他行中当前列的元素
        for(int i = 0; i < n; i++)
        {
            if(i != row && fabs(a[i][col]) > eps)
            {
                double c = a[i][col] / a[row][col];
                for(int j = col; j <= m; j++) 
                    a[i][j] -= a[row][j] * c;
            }
        }
        ++row;
        ++rank;
    }

    // 构造解向量
    ans.assign(m, 0);
    for(int i = 0; i < m; i++)
    {
        if(pos[i] != -1) ans[i] = a[pos[i]][m] / a[pos[i]][i]; // 计算主变量的解
    }

    // 验证解是否满足所有方程
    for(int i = 0; i < n; i++)
    {
        double sum = 0;
        for(int j = 0; j < m; j++) 
            sum += ans[j] * a[i][j];
        
        // 如果存在某个方程无法满足，返回无解
        if(fabs(sum - a[i][m]) > eps) return -1; // 无解
    }

    // 如果某些列没有主元，说明存在自由变量，返回无限解
    for(int i = 0; i < m; i++) 
        if(pos[i] == -1) return 2; // 无穷多解

    return 1; // 唯一解
}

int main()
{
    int n, m;
    cin >> n >> m;  // 输入方程个数n和未知数个数m
    vector< vector<double> > v(n); // 增广矩阵

    // 输入增广矩阵
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j <= m; j++)
        {
            double x;
            cin >> x;
            v[i].push_back(x);
        }
    }

    vector<double> ans; // 解向量
    int result = Gauss(v, ans); // 调用高斯消元函数

    if(result == 1) 
    {
        // 输出唯一解
        for(int i = 0; i < m; i++) 
            cout << fixed << setprecision(5) << ans[i] << ' ';
    }
    else if(result == 2) 
        cout << "Infinite solutions\n"; // 无限解
    else 
        cout << "No solution\n"; // 无解
    
    return 0;
}
```

## 3. 验证步骤的重要性

### 验证步骤的作用

验证步骤的核心代码如下：

```cpp
for(int i = 0; i < n; i++)
{
    double sum = 0;
    for(int j = 0; j < m; j++) 
        sum += ans[j] * a[i][j];
    
    if(fabs(sum - a[i][m]) > eps) 
        return -1; // 无解
}
```

这个步骤的作用是确保通过高斯消元得到的解 `ans` 可以满足原始的增广矩阵。通过验证所有方程是否都成立，它可以帮助检测以下几种情况：

1. **无解的情况**：如你的示例中，方程组内部存在矛盾时，消元可能不会立即暴露这个问题。验证步骤确保检测到矛盾。
2. **自由变量的存在**：当方程组有多个解（自由变量的存在）时，验证步骤确保选定的解（自由变量设为0的特解）也是有效解。
3. **数值误差**：浮点数计算中可能会产生微小误差，验证步骤确保这些误差不会导致错误解。

### 示例说明

考虑以下无解的线性方程组：

$$
\begin{cases}
x_1 + x_2 = 3 \\
2x_1 + 2x_2 = 4
\end{cases}
$$

通过高斯消元过程可以得到：

1. 消元后，得到增广矩阵：
   $$
   \begin{bmatrix}
   2 & 2 & | & 4 \\
   0 & 0 & | & -2
   \end{bmatrix}
   $$
2. 解向量为 `ans = [2, 0]`。
3. 验证时，第二个方程显然不成立：
   $$
   0 \times 2 + 0 \times 0 = 0 \neq -2
   $$
   因此，返回 `-1` 表示**无解**。

### 验证步骤是否必要？

**答案是肯定的**，验证步骤在处理以下情况时尤为必要：
- **无解的系统**：如上述示例，高斯消元过程中可能不会立即发现矛盾，而验证步骤可以捕捉到这一点。
- **自由变量**：当存在自由变量时，验证可以确保特定解（例如将自由变量设为0）仍满足所有方程。
- **数值误差**：防止浮点数运算中的微小误差导致错误解。
