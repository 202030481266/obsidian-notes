
# 题目 

最近学习异或线性基的时候接触到了一道非常难的问题：

[最大XOR路径和](https://www.luogu.com.cn/problem/P4151)

这是一道十分困难的问题，难点在于两个地方：

1. 图中的不同异或和路径的表达可以表为基环的组合加上一条简单路径。
2. 基环可以使用DFS构建得到，并且能够表示图中的所有环（环空间）。

# AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn = 50010;
int n, m;
vector<pair<int, ll>> g[maxn];
ll s[maxn]; // 从起点到节点u的异或和
bool vis[maxn];
ll basis[64];

void insert_basis(ll x) {
    for (int i = 63; i >= 0; --i) {
        if ((x >> i) & 1) {
            if (!basis[i]) {
                basis[i] = x;
                return;
            }
            x ^= basis[i];
        }
    }
}

void dfs(int u) {
    vis[u] = true;
    for (auto [v, w] : g[u]) {
        if (!vis[v]) {
            s[v] = s[u] ^ w;
            dfs(v);
        } else {
            ll cycle_xor = s[u] ^ w ^ s[v];
            if (cycle_xor) {
                insert_basis(cycle_xor);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n >> m;
    int u, v;
    ll w;
    for (int i = 0; i < m; ++i) {
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        if (u != v)
            g[v].push_back({u, w});
    }
    dfs(1);
    ll ans = s[n];
    for (int i = 63; i >= 0; --i) {
        if ((ans ^ basis[i]) > ans) {
            ans ^= basis[i];
        }
    }
    cout << ans << '\n';
    return 0;
}
```

# Cycle Basis

[基环的算法证明](https://math.stackexchange.com/questions/3952673/basis-of-fundamental-cycles)
[Fundamental Cycle Basis](https://en.wikipedia.org/wiki/Cycle_basis#Fundamental_cycles)

---
### Cycle Space

为了定义循环空间，我们首先定义图 $G$ 的边空间。可以通过两种等价的方式进行定义：

1. 作为 $G$ 的所有生成子图的集合（包括所有顶点，尽管可能具有度数为0的边）。两个子图 $H_1$ 和 $H_2$ 可以通过它们的边集的对称差进行“相加”：如果某条边恰好在 $H_1$ 或 $H_2$ 中，那么它会出现在 $H_1 \Delta H_2$ 中。

2. 作为从 $E(G)$ 到 $\mathbb{F}_2$（具有两个元素的域）的所有函数集。这是一个向量空间，定义在 $\mathbb{F}_2$ 上；在该域上标量乘法并不有趣，而向量加法是逐点相加。

每个循环（连同可能不在其内的顶点）为 $G$ 提供了一个生成子图，因此它是边空间的一个元素。用第二种方式来考虑，给定一个循环 $C$，我们可以定义它的指示函数 $f: E(G) \to \mathbb{F}_2$，通过设置 $f(e) = 1$ 当 $e$ 是 $C$ 的一条边时，否则 $f(e) = 0$。

通过添加循环得到的边空间中的所有元素的集合就是循环空间。它还有一个替代的定义：**它是所有顶点度数为偶数的生成子图的集合**。（本质上就是欧拉子图的集合）

---

### Cycle Basis

循环基是生成循环空间的最小循环集。基础循环基是从生成树 $T$ 获得的：对于每一条不在 $T$ 中的边 $e \in E(T)$，我们通过找到 $T$ 中连接 $e$ 的两个端点之间的唯一路径来获得循环 $C_e$，然后将其与边 $e$ 本身组合形成一个循环。

为什么基础循环基就是一个循环基。由于它由循环组成，因此它生成了循环空间的一个子空间。它是线性独立的，因为每个 $C_e$ 是基础循环空间中唯一包含边 $e$ 的元素。（线性独立意味着没有非平凡的和能够加到零函数：没有非平凡的对称差可以得到空图。这在这里是正确的，因为不同的基础循环 $C_e \Delta C_{e'} \Delta C_{e''} \Delta \dots$ 会包含边 $e, e', e'', \dots$，并不会为空。）

循环基的最后一个要求是它能够生成循环空间中的每个元素。所以设 $H$ 是循环空间的一个元素。

### 目标

证明**基础循环基**确实能够生成循环空间中的所有元素，也就是说，**循环空间中的每个元素**都可以表示为**基础循环基**中若干循环的组合。

### 背景知识

1. **生成树 $T$**：这是图中的一个无环子图，包含了所有顶点，且有最少的边（即树）。它包含 $n-1$ 条边，其中 $n$ 是顶点数。

2. **基础循环基**：对于每一条不在生成树 $T$ 中的边 $e$，我们可以通过将该边 $e$ 加入生成树 $T$ 来形成一个唯一的循环。这些循环就构成了基础循环基。

3. **循环空间**：图中由所有边构成的向量空间，包含所有具有偶数度数的生成子图。这意味着每个顶点必须连接偶数条边。

### 证明分解
#### 1. 设 $H$ 是循环空间中的一个元素（子图）

首先，假设我们已经有了一个在循环空间中的元素 $H$，也就是一个生成子图，它满足所有顶点的度数都是偶数。目标是展示 $H$ 可以通过基础循环基中的若干循环来表示。

#### 2. 使用对称差操作

回忆一下，在图的边集上，我们使用对称差（$\Delta$）作为“加法”操作。对称差的含义是：两组之间只有在某个集合中而不在另一个集合中的元素会保留（例如：如果某条边在 $H$ 中但不在 $C$ 中，或者在 $C$ 中但不在 $H$ 中，对称差的结果会包含该边；如果一条边同时在 $H$ 和 $C$ 中，则该边会被消除）。

因此，证明开始时，我们考虑 $H$ 与基础循环基中的循环 $C_{e_1}, C_{e_2}, \dots, C_{e_k}$ 之间的对称差：

$$ H \Delta C_{e_1} \Delta C_{e_2} \dots \Delta C_{e_k}. $$

这里，$e_1, e_2, \dots, e_k$ 是 $H$ 中那些不属于生成树 $T$ 的边。通过这些对称差操作，我们逐渐“消去” $H$ 中的这些边，最终得到一个子图。

#### 3. 剩下的图是生成树的子图

当我们对 $H$ 与基础循环基中的循环执行对称差操作时，结果仍然在循环空间中。这是因为对称差操作会保持偶数度的性质。

关键的一步是：经过对这些循环的对称差操作后，结果图不仅在循环空间中，还成为生成树 $T$ 的一个子图。这意味着我们删除了所有不在生成树中的边，只剩下生成树的边。

#### 4. 剩下的图中没有循环

生成树本身是无环的，因此任何包含生成树的子图都不能有循环。由于循环空间中的任何非平凡元素必须包含循环，而现在这个子图没有循环，它只能是平凡的（即空图）。因此，所得到的图一定是“空图”，也就是说，我们已经完全消除了 $H$ 中的所有额外边。

#### 5. 结论

通过对称差操作，最后我们得到的图是平凡的（空图），这意味着 $H$ 可以通过基础循环基中的循环表示。因此，循环空间中的每个元素都可以用基础循环基的线性组合来表示。

### 总结

证明的核心思想是：任何循环空间中的元素 $H$ 都可以通过对基础循环基中的某些循环进行对称差操作，通过逐步“消除”它的额外边，最终得到一个无环子图（生成树的子图）。因为生成树无环且与循环基中的对称差操作一致，最后的结果必须是平凡的，表明我们成功用基础循环基中的循环生成了 $H$。

# 路径差集$D$

题解区里面清一色的标准错误题解，看不下去了，自己来手动证明这一个关键事实。我们首先探讨一下不同路径集合的差集$D$。

假设生成树中生成的简单路径$P_r$，还有就是任意路径$P$。（1到n）

我们很容易知道的是一个简单路径中，除了1和n之外，其他的所有节点的度都是偶数，因为都是以2的倍数出现，而1和n必然是奇数。其中，我们有：

$$
D=P_r \Delta P
$$
对于路径上的每一个点而言，它的度有：
$$
degree(v)=degree_{P_r}(v)\ \Delta\ degree_{P}(v)
$$
这里的运算什么意思呢？实际上很简单，就是取并集减去交集。比如说对于$P_r$而言，$v$ 有4条边相连，那么$degree_{P_r}(v)$其实就是4，同样的我们假设在$P$中$v$的度数是2，那么他们有一条边相同，所有可以得到$degree(v)=4+2-2=4$，总共就是4。

**这个计算公式可以告诉我们无论最后怎么计算，所有的点的度数都是偶数，这是一个重要的特征，它反应了差集$D$的本质上是一个欧拉图，每一个连通分量都是由一个循环组成**。

所以，我们计算不同路径的异或和的时候，就可以通过不同的循环组合来改变控制差集$D$，从而达到改变路径异或和，而不同的循环组合恰好可以由一组基本Cycle basis来构造。