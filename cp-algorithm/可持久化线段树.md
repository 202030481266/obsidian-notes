# 定义

可持久化线段树也叫做主席树，其实还是属于最经典的可持久化的思想：**只修改其中的变化的树上路径，和可持久化左偏树非常类似**。

# 单点修改可持久化线段树

1，单点修改操作，不需要懒更新机制
2，新版本的线段树生成时，沿途节点新建，其他节点复用，新建的空间为$O(\log n)$
3，查询单点$x$的信息时，根据版本号，从头节点往下找到$x$位置对应的节点即可
4，查询范围$[l,r]$的信息时，利用 $r\text{版本的信息} - (l-1)\text{版本的信息}$ 完成查询
5，总空间$O(n * 4 + n * \log n)$。
## 代码实现

主席树的代码非常好写，所以不细谈，直接看代码就能一目了然了。下面是关于主席树的模板题目的AC代码，题目链接：[单点修改+单点查询 可持久化线段树](https://www.luogu.com.cn/problem/P3919)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

const int maxn = 1e6 + 7;
const int N = maxn * 23;

int root[maxn], ls[N], rs[N], val[N];
int tot = 0, a[maxn], n, m;

// 动态开点
int build(int l, int r) {
    int rt = ++tot;
    if (l == r) {
        val[rt] = a[l];
        return rt;
    }
    int mid = (l + r) >> 1;
    ls[rt] = build(l, mid);
    rs[rt] = build(mid + 1, r);
    return rt;
}

int clone(int x) {
    int y = ++tot;
    ls[y] = ls[x];
    rs[y] = rs[x];
    val[y] = val[x];
    return y;
}

int update(int rt, int l, int r, int p, int v) {
    int c = clone(rt);
    if (l == r) {
        val[c] = v;
        return c;
    }
    int mid = (l + r) >> 1;
    if (p <= mid) ls[c] = update(ls[c], l, mid, p, v);
    else rs[c] = update(rs[c], mid + 1, r, p, v);
    return c;
}

int query(int rt, int l, int r, int p) {
    if (l == r) return val[rt];
    int mid = (l + r) >> 1;
    if (p <= mid) return query(ls[rt], l, mid, p);
    else return query(rs[rt], mid + 1, r, p);
}

int main() {
    ios::sync_with_stdio(0); cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    root[0] = build(1, n);
    int op, version, value, pos;
    for (int i = 1; i <= m; ++i) {
        cin >> version >> op;
        if (op == 1) {
            cin >> pos >> value;
            root[i] = update(root[version], 1, n, pos, value);
        }
        else {
            cin >> pos;
            cout << query(root[version], 1, n, pos) << '\n';
            root[i] = root[version];
        }
    }
    return 0;
}
```

上面是最为简单的主席树运用模板，其中主要涉及到了**单点修改和单点查询**，那么下面就介绍另外一种也是非常经典的可持久化线段树的运用：**静态区间第K小问题**。
### 问题描述

给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。
### 输入格式

第一行包含两个整数，分别表示序列的长度 $n$ 和查询的个数 $m$。  
第二行包含 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个元素 $a_i$。   
接下来 $m$ 行每行包含三个整数 $l, r, k$ , 表示查询区间 $[l, r]$ 内的第 $k$ 小值。
### 输出格式

对于每次询问，输出一行一个整数表示答案。
### 样例

```
5 5
25957 6405 15770 26287 26465 
2 2 1
3 4 1
4 5 1
1 2 2
4 4 1
```
### 样例输出

```
6405
15770
26287
25957
26287
```
### 样例解释

$n=5$，数列长度为 $5$，数列从第一项开始依次为$\{25957, 6405, 15770, 26287, 26465\}$。

- 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。
- 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。
- 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。
- 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。
- 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。

这种题目难点在于如果在线段树上每一个节点都维护一个值域计数器，空间占用将会十分庞大，一个经典的技巧就是使用离散化将现有的值域压缩到一个密集的连续区间里面，但是这依然不足以构建庞大的线段树。可持久化线段树的本质依然是暴力维护（和左偏树一样），能够在极少的空间和时间内完成一个持久化操作，复杂度都是$O(\log n)$。如果使用值域线段树的话，那么每一个版本$version$的线段树就代表了其中下标为$[1,version]$中数组的值域的计数情况，这样就可以大大减少空间的占用。同时利用这个值域线段树，我们就可以很方便的计算区间内的值域分布，很巧妙。

题目链接：[单点修改 + 范围查询 可持久化线段树](https://www.luogu.com.cn/problem/P3834)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

const int maxn = 2e5 + 7;
const int N = maxn * 25;

int root[maxn], ls[N], rs[N], siz[N], tot;
int a[maxn], n, m, b[maxn], bn;

int kth(int x) {
    return lower_bound(b + 1, b + 1 + bn, x) - b;
}

void pushup(int rt) {
    siz[rt] = siz[ls[rt]] + siz[rs[rt]];
}

int build(int l, int r) {
    int rt = ++tot;
    if (l == r) {
        siz[rt] = 0;
        return rt;
    }
    int mid = (l + r) >> 1;
    ls[rt] = build(l, mid);
    rs[rt] = build(mid + 1, r);
    return rt;
}

int clone(int x) {
    int y = ++tot;
    ls[y] = ls[x];
    rs[y] = rs[x];
    siz[y] = siz[x];
    return y;
}

int update(int rt, int l, int r, int p) {
    int c = clone(rt);
    if (l == r) {
        siz[c] += 1;
        return c;
    }
    int mid = (l + r) >> 1;
    if (p <= mid) ls[c] = update(ls[c], l, mid, p);
    else rs[c] = update(rs[c], mid + 1, r, p);
    pushup(c);
    return c;
}

int query(int i, int j, int l, int r, int k) {
    if (l == r) {
        return l;
    }
    int sz = siz[ls[j]] - siz[ls[i]];
    int mid = (l + r) >> 1;
    if (sz >= k) {
        return query(ls[i], ls[j], l, mid, k);
    }
    return query(rs[i], rs[j], mid + 1, r, k - sz);
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b + 1, b + 1 + n);
    bn = unique(b + 1, b + 1 + n) - b - 1;
    root[0] = build(1, bn);
    for (int i = 1; i <= n; ++i) {
        root[i] = update(root[i-1], 1, bn, kth(a[i]));
    }
    for (int i = 1, l, r, k; i <= m; ++i) {
        cin >> l >> r >> k;
        cout << b[query(root[l-1], root[r], 1, bn, k)] << '\n';
    }
    return 0;
}
```

# 区间修改可持久化线段树

区间修改的主席树的更新方法和单点修改类似，同时结合了懒更新的机制，每当更新了一个节点的时候就会创建一个新的节点。这样的话，不仅在update的时候会占用新的数组，在查询的时候也会占用新的数组空间，因为懒更新的机制是存在于查询和更新操作的。

1，范围修改操作，需要懒更新机制
2，仿照单点修改的可持久化线段树
3，每来到一个节点，新建节点并且复制老节点的信息
4，当前节点的懒更新下发时(down过程)，左右孩子也新建，接收懒更新信息，务必让老节点信息保持不变

生成新版本的线段树，空间占用$O(log n)$，只要有懒更新的下发，必然新建节点，所以生成新版本的线段树、执行查询操作，都会增加空间占用，所以这个时候该版本的线段树内部可能发生节点的替换和改变。

如果生成$n$个版本的线段树，有$m$个查询操作，总空间$O(n * 4 + n * \log n + m * \log n)$。

## 经典懒更新机制写法

优点：通用，对于所有的线段树维护方法都可以使用这种方法来进行编写可持久化更新。
缺点：占用空间巨大，要看看题目有没有卡常数或者卡空间。

经典例题：[区间更新 + 区间查询 可持久化线段树](https://www.spoj.com/problems/TTM/)

```cpp
// 区间更新 + 区间查询
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

const int maxn = 1e5 + 7;
const int N = maxn * 70;

int root[maxn], a[maxn], tot, n, m;
int ls[N], rs[N];
ll sum[N], tag[N];

int clone(int x) {
    int y = ++tot;
    ls[y] = ls[x];
    rs[y] = rs[x];
    sum[y] = sum[x];
    tag[y] = tag[x];
    return y;
}

void pushup(int rt) {
    sum[rt] = sum[ls[rt]] + sum[rs[rt]];
}

void pushdown(int rt, int l, int r) {
    if (tag[rt]) {
        ls[rt] = clone(ls[rt]);
        rs[rt] = clone(rs[rt]);
        int mid = (l + r) >> 1;
        sum[ls[rt]] += tag[rt] * (mid - l + 1); 
        sum[rs[rt]] += tag[rt] * (r - mid);
        tag[ls[rt]] += tag[rt];
        tag[rs[rt]] += tag[rt];
        tag[rt] = 0;
    }
}

int build(int l, int r) {
    int rt = ++tot;
    if (l == r) {
        sum[rt] = a[l];
        return rt;
    }
    int mid = (l + r) >> 1;
    ls[rt] = build(l, mid);
    rs[rt] = build(mid + 1, r);
    pushup(rt);
    return rt;
}

int update(int rt, int l, int r, int L, int R, int z) {
    int c = clone(rt);
    if (L <= l && r <= R) {
        sum[c] += (r - l + 1) * z;
        tag[c] += z;
        return c;
    }
    int mid = (l + r) >> 1;
    pushdown(c, l, r);
    if (R <= mid) {
        ls[c] = update(ls[c], l, mid, L, R, z);
    }
    else if (L > mid) {
        rs[c] = update(rs[c], mid + 1, r, L, R, z);
    }
    else {
        ls[c] = update(ls[c], l, mid, L, mid, z);
        rs[c] = update(rs[c], mid + 1, r, mid + 1, R, z);
    }
    pushup(c);
    return c;
}

ll query(int rt, int l, int r, int L, int R) {
    if (L <= l && r <= R) {
        return sum[rt];
    }
    pushdown(rt, l, r);
    int mid = (l + r) >> 1;
    ll ans = 0;
    if (R <= mid) ans = query(ls[rt], l, mid, L, R);
    else if (L > mid) ans = query(rs[rt], mid + 1, r, L, R);
    else ans = query(ls[rt], l, mid, L, mid) + query(rs[rt], mid + 1, r, mid + 1, R);
    pushup(rt);
    return ans;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    root[0] = build(1, n);
    char op;
    for (int i = 1, l, r, t = 0, d; i <= m; ++i) {
        cin >> op;
        if (op == 'C') {
            cin >> l >> r >> d;
            root[t + 1] = update(root[t], 1, n, l, r, d);
            ++t;
        }
        else if (op == 'Q') {
            cin >> l >> r;
            cout << query(root[t], 1, n, l, r) << '\n';
        }
        else if (op == 'H') {
            cin >> l >> r >> d;
            cout << query(root[d], 1, n, l, r) << '\n';
        }
        else {
            cin >> t;
        }
    }
    return 0;
}
```

## 永久标记更新方法

标记永久化，懒更新不再下发，变成只属于某个范围的标记信息，上下级的标记之间，不再相互影响。查询时，懒更新也不再下发，从上往下的过程中，维护标记的叠加信息，即可完成查询。

标记挂在父范围不下发，也能在后续访问时正确合并，所谓的标记永久化，并不是标记信息的值不再变化，而是上下级标记之间不再相互影响。这个技巧可以运用在可持久化线段树，使用标记永久化可以减少空间占用，但是应用范围比较窄。其中，**范围增加 + 查询累加和，这一类的线段树，修改和查询的性质都有可叠加性，可以标记永久化**。

范围重置、查询最大值/最小值，这一类的线段树，修改和查询的性质不具有可叠加性，只能使用经典的懒更新方式。一旦标记永久化，就没有了懒更新的下发，那么查询时就不再新建节点了，就可以大量减少空间的使用。

如果生成$n$个版本的线段树，有$m$个查询操作，总空间$O(n * 4 + n * \log n)$。

### 如何理解标记永久化

实际上，我对于标记永久化这个技巧的命名有点不适应，本质上来说，懒更新的机制是在于保证了查询的时候查询的路径上的节点的值是绝对正确的，比如对于区间和，这个节点表示的区间的和的值就一定是$s[rt]$，这一个过程在可持久化的时候会克隆新的节点从而保证正确性。标记永久化的意思就是抛弃了这样的实时正确性，将该节点的值表示为：

$$
sum[rt]=s[rt]+(r-l+1)*\sum_{father}tag[father]
$$
其中，$s[rt]$表示的是直接作用于该区间的修改的和，$\sum_{father}tag[father]$表示该区间被修改，但是没有直接作用到该区间的数字的和。（区分有没有被作用到就是$dfs$递归更新的时候有没有走到该区间或者说节点）

```cpp
// 范围累加和， 区间修改 + 区间查询
// 测试链接：https://acm.hdu.edu.cn/showproblem.php?pid=4348

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

const int maxn = 1e5 + 7;
const int N = maxn * 25;

int root[maxn], a[maxn], tot, n, m;
int ls[N], rs[N];
ll sum[N], tag[N];

int build(int l, int r) {
    int rt = ++tot;
    if (l == r) {
        sum[rt] = a[l];
        return rt;
    }
    int mid = (l + r) >> 1;
    ls[rt] = build(l, mid);
    rs[rt] = build(mid + 1, r);
    sum[rt] = sum[ls[rt]] + sum[rs[rt]];
    return rt;
}

int update(int rt, int l, int r, int L, int R, ll z) {
    int c = ++tot, left = max(l, L), right = min(r, R);
    ls[c] = ls[rt];
    rs[c] = rs[rt];
    sum[c] = sum[rt] + (right - left + 1) * z;
    tag[c] = tag[rt];
    if (L <= l && r <= R) {
        tag[c] += z;
        return c;
    }
    int mid = (l + r) >> 1;
    if (R <= mid) ls[c] = update(ls[c], l, mid, L, R, z);
    else if (L > mid) rs[c] = update(rs[c], mid + 1, r, L, R, z);
    else {
        ls[c] = update(ls[c], l, mid, L, mid, z);
        rs[c] = update(rs[c], mid + 1, r, mid + 1, R, z);
    }
    return c;
}

ll query(int rt, int l, int r, int L, int R, ll tag_sum) {
    if (L <= l && r <= R) return sum[rt] + tag_sum * (r - l + 1);
    int mid = (l + r) >> 1;
    if (R <= mid) return query(ls[rt], l, mid, L, R, tag_sum + tag[rt]);
    else if (L > mid) return query(rs[rt], mid + 1, r, L, R, tag_sum + tag[rt]);
    else return query(ls[rt], l, mid, L, mid, tag_sum + tag[rt]) + query(rs[rt], mid + 1, r, mid + 1, R, tag_sum + tag[rt]);
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    root[0] = build(1, n);
    char op;
    for (int i = 1, l, r, t = 0, d; i <= m; ++i) {
        cin >> op;
        if (op == 'C') {
            cin >> l >> r >> d;
            root[t + 1] = update(root[t], 1, n, l, r, d);
            ++t;
        }
        else if (op == 'Q') {
            cin >> l >> r;
            cout << query(root[t], 1, n, l, r, 0) << '\n';
        }
        else if (op == 'H') {
            cin >> l >> r >> d;
            cout << query(root[d], 1, n, l, r, 0) << '\n';
        }
        else {
            cin >> t;
        }
    }
    return 0;
}
```

