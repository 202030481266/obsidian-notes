
## 定义
### 基本概念

1. **异或运算（XOR，^）**：
   - 二进制异或运算是一种按位的运算，如果对应的位不同，结果为 1，相同则结果为 0。
   - 异或运算满足交换律和结合律，因此可以在异或运算下定义“线性独立”和“线性组合”。

2. **异或空间的线性基**：
   - 给定一个整数集合，异或空间中的线性基是一组数，它们之间是“异或线性独立”的。也就是说，基向量之间的任何异或组合都不会产生其他基向量（除了 0 以外）。
   - 通过这些线性基的异或组合，能够表示原始整数集合中的任意数。
   - 换句话说，线性基是能够生成该整数集合的最小异或子集。

### 线性基的计算步骤

1. **高位优先处理**：
   从最高位开始处理，目的是保证每个线性基在不同的位上有贡献。我们遍历给定的整数集合，将每个整数逐步插入线性基集合，确保新数不能通过现有线性基异或得出。

2. **插入新向量**：
   对于每个新向量，我们尝试用当前的线性基消去其最高的1位。如果无法完全消去该向量，它就会成为线性基中的新基向量。

3. **最终结果**：
   完成后，线性基中的元素是异或空间中的生成元，能够通过异或组合生成原集合中的任意数。

### 例子

假设我们有一个整数集合 `{5, 7, 10}`，我们想构建它的线性基：

- 首先将 5 表示为二进制：`101`
- 其次将 7 表示为二进制：`111`
- 再将 10 表示为二进制：`1010`

然后通过高位优先的方式处理这些数，逐步插入线性基集合，确保它们线性独立。如果我们最终的线性基是 `{101, 111}`，那么可以通过异或这些基向量组合生成所有其他整数。

### 应用场景

- **最小化表示**：对于一组整数，用异或空间线性基可以最小化表示所需的元素数量。
- **查询问题**：通过异或线性基，可以快速求解一组整数集合的最大异或值、最小异或值等问题。
- **密码学和编码理论**：在某些密码系统和纠错码中，异或线性基的概念也有重要应用。

总结来说，异或空间的线性基可以帮助我们理解和操作基于异或运算的线性结构，尤其在大规模计算和优化问题中有广泛应用。

---

## 构造异或线性基

### 1. **贪心算法的策略**

贪心算法的核心思想是，每一步都选择当前最优的选择。对于异或空间线性基问题，这个“最优选择”指的是确保每次加入的新向量在已有线性基的基础上尽可能贡献更多的高位信息，换句话说，尽可能在最高的位上贡献一个独立的1位。这可以通过下列步骤来实现：

1. 按照从高位到低位的顺序依次处理每一个数。
2. 如果当前数在某一高位无法被已有线性基中的元素异或消除（也就是现有线性基中没有元素可以消去当前数的该高位1），就将该数加入线性基，作为新的基向量。

通过这个过程，新的基向量总是在已有基向量无法覆盖的最高位贡献独立信息。

### 2. **算法的正确性证明**

这个算法的正确性可以从以下两个方面来理解：

#### 2.1 **线性独立性**

在算法中，每当我们引入一个新向量到线性基中时，都会确保它无法通过已有的线性基元素组合生成。也就是说，新的基向量一定是“线性独立”的。因此，这个贪心策略保证了生成的线性基中的所有向量都是线性独立的。

具体而言：
- 假设当前处理的数为 $x$，并且我们想检查是否可以通过当前基向量的线性组合（即异或）生成 $x$。
- 我们尝试用线性基中的向量逐步消去 $x$ 的高位，直到无法再消去时，剩下的 $x$ 就在某一位上仍然是1，而这个1不能被当前基向量组合生成。
- 这时，$x$ 一定是线性独立的，并且它的这一位贡献了新的线性信息，因此将 $x$ 加入线性基是正确的。

#### 2.2 **生成所有可能的组合**

贪心算法不仅保证了线性独立性，还能保证最终生成的基向量可以组合出原集合中的所有元素。

- 每次引入新基向量时，它为线性空间贡献了新的自由度，表示可以生成更多的组合。
- 由于异或操作的结合律和交换律，任何数都可以通过线性基的异或组合生成。因此，最终得到的线性基可以生成原集合中的任意数。
- 这一点在高位优先策略下得以保证：每次加入新的基向量时，确保它贡献了现有基向量无法组合生成的部分，从而能够扩展生成空间。

### 3. **为什么贪心策略是高效的？**

- **时间复杂度**：由于算法中每次处理一个向量时都尝试将其高位依次与已有基向量进行异或操作，最多需要处理每个数的最高位。对于位宽为 $L$ 的整数集，处理每个数的复杂度是 $O(L)$，而总的复杂度是 $O(nL)$，其中 $n$ 是整数的个数，$L$ 是整数的最大位数。
- **高位优先**：高位优先的贪心策略保证了每次加入的基向量都能够覆盖更多位上的独立信息。这种策略的效率高是因为每次都尽量增加线性空间的维度，避免不必要的冗余计算。

### 4. **几何直观**

从几何角度来看，贪心算法确保了每次引入的新向量都能够在向量空间中增加一个新的维度。就像在欧几里得几何中添加一条与现有向量不共线的新向量，它可以构成一个新的线性空间一样，在异或空间中，每次添加的基向量都是现有基向量的独立扩展。

### 5. **总结**

贪心算法在求解异或空间的线性基问题时是正确的，因为它每次都选择在高位上无法由现有基向量表示的向量，从而确保了线性独立性。同时，通过结合律和交换律的性质，它保证最终得到的基能够生成所有可能的数。因此，这种贪心策略高效且正确。

---

## 代码

### 异或线性基的常见应用

异或线性基在算法竞赛和计算机科学中有广泛的应用，主要集中在处理涉及异或操作的问题。以下是一些最常见的应用：

#### 1. 求最大子集异或和（Maximum XOR Subset Sum）

- **问题描述**：给定一个整数集合，求其所有非空子集的异或和的最大值。
- **解决方案**：构建异或线性基，然后通过将线性基中的元素逐步尝试异或，得到最大的可能值。

#### 2. 计算不同的异或和数量

- **问题描述**：求所有子集的异或和有多少种不同的值。
- **解决方案**：构建异或线性基，计算其维度 $d$，不同的异或和数量即为 $2^d$。

#### 3. 求第 $k$ 小的异或和

- **问题描述**：给定一个整数集合，按升序排列其所有子集的异或和，求第 $k$ 个异或和。
- **解决方案**：构建异或线性基，然后通过对线性基中的元素进行适当的排序和动态规划，找到第 $k$ 小的值。

#### 4. 判断一个数能否表示为给定集合的异或和

- **问题描述**：给定一个目标值，判断是否存在一个子集，其异或和等于目标值。
- **解决方案**：将目标值与线性基进行高斯消元，如果最终结果为 0，则表示可以表示。

#### 5. 求最小不可表示的异或和

- **问题描述**：求最小的正整数，不能表示为给定集合的子集异或和。
- **解决方案**：类似于“最小不可表示金额”问题，通过构建线性基并分析其覆盖范围。

#### 6. 解异或形式的线性方程组

- **问题描述**：求解形如 $Ax = b$ 的方程组，其中运算为异或。
- **解决方案**：使用异或线性基进行高斯消元，找到解或判断是否有解。

### C++ 实现模板代码

以下提供一个常用的异或线性基的 C++ 模板代码，并对关键部分进行解释。

#### 1. 异或线性基的构建

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXL = 64; // 对于 64 位整数

struct LinearBasis {
    long long basis[MAXL]; // basis[i] 表示在第 i 位上有一个 1 的基

    LinearBasis() {
        for (int i = 0; i < MAXL; ++i)
            basis[i] = 0;
    }

    void insert(long long x) {
        for (int i = MAXL - 1; i >= 0; --i) {
            if (!(x & (1LL << i))) continue; // 如果第 i 位不是 1，跳过
            if (!basis[i]) { // 如果第 i 位还没有基向量
                basis[i] = x;
                return;
            }
            x ^= basis[i]; // 消去第 i 位的 1
        }
    }

    long long getMax() {
        long long res = 0;
        for (int i = MAXL - 1; i >= 0; --i) {
            if ((res ^ basis[i]) > res)
                res ^= basis[i];
        }
        return res;
    }

    long long getMin() {
        for (int i = 0; i < MAXL; ++i) {
            if (basis[i])
                return basis[i];
        }
        return 0;
    }

    bool canRepresent(long long x) {
        for (int i = MAXL - 1; i >= 0; --i) {
            if (!x) break;
            if (x & (1LL << i)) {
                if (!basis[i]) return false;
                x ^= basis[i];
            }
        }
        return x == 0;
    }

    int getCount() {
        int cnt = 0;
        for (int i = 0; i < MAXL; ++i) {
            if (basis[i])
                cnt++;
        }
        return cnt;
    }
};
```

##### 代码解释：

- **结构体 `LinearBasis`**：用于存储和操作异或线性基。
- **`basis[MAXL]`**：数组用于存储线性基，每个 `basis[i]` 对应第 $i$ 位为 1 的基向量。
- **`insert(long long x)`**：将元素 $x$ 插入线性基。
  - 从高位到低位遍历，如果当前位为 1：
    - 如果对应的 `basis[i]` 为空，直接将 $x$ 存入，这是一个新的基向量。
    - 如果 `basis[i]` 不为空，用 $x$ 异或 `basis[i]`，尝试消去当前位的 1。
- **`getMax()`**：获取所有子集异或和的最大值。
  - 从高位到低位尝试，如果异或当前 `basis[i]` 能使结果更大，就进行异或。
- **`getMin()`**：获取所有非零子集异或和的最小值。
  - 返回线性基中最小的非零元素。
- **`canRepresent(long long x)`**：判断 $x$ 能否由线性基表示。
  - 从高位到低位尝试用线性基消去 $x$，如果最终 $x$ 为 0，则可以表示。
- **`getCount()`**：获取线性基的维度，即基向量的数量。

#### 2. 应用示例

##### 求最大子集异或和

```cpp
int main() {
    int n;
    cin >> n;
    LinearBasis lb;
    for (int i = 0; i < n; ++i) {
        long long x;
        cin >> x;
        lb.insert(x);
    }
    cout << "最大子集异或和为：" << lb.getMax() << endl;
    return 0;
}
```

##### 判断一个数能否被表示

```cpp
int main() {
    int n;
    cin >> n;
    LinearBasis lb;
    for (int i = 0; i < n; ++i) {
        long long x;
        cin >> x;
        lb.insert(x);
    }
    long long target;
    cin >> target;
    if (lb.canRepresent(target)) {
        cout << "目标值可以被表示为子集的异或和。" << endl;
    } else {
        cout << "目标值无法被表示为子集的异或和。" << endl;
    }
    return 0;
}
```

##### 计算不同的异或和数量

```cpp
int main() {
    int n;
    cin >> n;
    LinearBasis lb;
    for (int i = 0; i < n; ++i) {
        long long x;
        cin >> x;
        lb.insert(x);
    }
    int d = lb.getCount();
    cout << "不同的异或和数量为：" << (1LL << d) << endl;
    return 0;
}
```

##### 求第 $k$ 小的异或和

求第 $k$ 小的异或和需要对线性基进行处理，使其满足某种形式，以便可以进行枚举。这里需要将线性基转换为下三角矩阵形式，并对基向量进行排序。

```cpp
// https://loj.ac/p/114

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<pii> vpii;

#define all(x) (x).begin(), (x).end()
#define rep(i, a, b) for(int i = (a); i < (b); ++i)
#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)

const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3fLL;

int n , m;

int clz(long long x) {
    if (x == 0) return 64; // 如果 x 为 0，返回 64（所有位都是零）

    int count = 0;
    while ((x & (1LL << 63)) == 0) { // 检查最高位
        count++;
        x <<= 1; // 左移 x
    }
    return count;
}

void solve() {
    cin >> n;
    vector<ll> basis;
    ll tmp;
    int flag = 0;
    for (int i = 0; i < n; ++i) {
        cin >> tmp;
        for (ll b : basis) {
            tmp = min(tmp, tmp ^ b);
        }
        if (tmp) basis.push_back(tmp);
        else flag = 1;
    }
    // 标准化
    sort(basis.begin(), basis.end(), greater<ll>());
    for (int i = 0; i < basis.size(); ++i) {
        for (int j = i + 1; j < basis.size(); ++j) {
            int hb = 63 - clz(basis[j]); // __builtin_clz() 函数会出错
            if (basis[i] & (1ll << hb)) {
                basis[i] ^= basis[j];
            }
        }
    }
    cin >> m;
    int N = basis.size();
    ll cnt = (1ll<<N)-1, k;
    while (m--) {
        cin >> k;
        k -= flag;
        if (!k) {
            cout << 0 << '\n';
            continue;
        }
        if (k > cnt) {
            cout << -1 << '\n';
            continue;
        }
        ll ans = 0;
        for (int i = N-1; i >= 0; --i) {
            if (k & (1ll<<i)) {
                ans ^= basis[N-i-1];
            }
        }
        cout << ans << '\n';
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    solve();
    return 0;
}
```

##### 代码解释：

- **`rebuild()`**：重构线性基，使其满足下三角矩阵形式，便于求第 $k$ 小的异或和。
- **`kthSmallest(long long k)`**：求第 $k$ 小的异或和。
  - 检查 $k$ 是否超出范围，即 $k \geq 2^n$。
  - 通过二进制位表示 $k$，从而决定是否选择对应的基向量。

### x=min(x,x^b)难点理解

这是一个相当有难度的地方，但是很多人可能没有注意到，这个传统意义上的构造方法是完全不同的。传统意义上由于每一次都是枚举位去限定每一个位只能对应一个线性基，所以必然不会出现重复，所以每一次都是找到之后直接break了。然后这个每一次减小的方法必然要遍历所有的线性基。为什么呢？因为他要保证已有的线性基固定后，后面所有的线性基在此位置上为0。这样说其实很难理解，但是仔细想想还是挺巧妙，没那么难。

比如说，我已经找到了第1,2,4位置的线性基，那么数字15会变成什么？因为1,2,4线性基固定了，所以15一定会变成9，就是属于3的线性基。然后后面所有在1,2,4,3位置上有1的线性基，都会异或掉，此位置变成0，并且永远不会再变为1！这就说明每一次变为0都是不可逆的，这就恰好可以构造出每一个位置对应一个线性基的情况。

这基本上说明了一个情况，当找到属于位置$i$的线性基时，前面的数字大于这个数字或者小于这个数字，如果该数字对应的线性基位置$j$小于$i$，那么当前数字在$j$必然为0，如果$j$大于$i$，那么无所谓，是0还是1都不影响结果，和传统的算法一样。

### 标准的异或线性基构建方法

在标准的异或线性基构建中，我们通常按照从高位到低位的顺序处理，每次尝试消除最高位的 `1`。但在您的代码中，通过使用 `min(x, x ^ b)`，我们并没有严格按照位的顺序，而是尝试在每一步尽可能地减小 `x`。所以要进行一个处理，将所有的线性基构造为一个下三角的形式：

```cpp
// 标准化
sort(basis.begin(), basis.end(), greater<ll>());
for (int i = 0; i < basis.size(); ++i) {
	for (int j = i + 1; j < basis.size(); ++j) {
		int hb = 63 - clz(basis[j]); // __builtin_clz() 函数会出错
		if (basis[i] & (1ll << hb)) {
			basis[i] ^= basis[j];
		}
	}
}
```

在标准的线性基中，每个位置对应的线性基向量仅有一个元素为 1，其余元素均为 0。这意味着可以通过选择不同的线性基向量构造出多种异或和。具体而言，给定 $n$ 个线性基向量，能够生成的异或和总数为 $2^n$，因为每个线性基向量的选择与否都会影响最终结果。

在求解第 $k$ 大的异或和时，可以通过选取线性基中相应的向量进行异或操作来实现。值得注意的是，在构造异或和时，零值也应被考虑在内。具体而言，如果不选择任何线性基向量，得到的结果为 $0$。因此，在计算第 $k$ 大的异或和时，必须将 $0$ 纳入考虑，这可能会影响最终的结果，特别是在 $k \leq 2^n$ 的情况下。
### 总结

- **`insert` 函数：** 构建线性基，通过尝试消除 `x` 中的已知信息，确定其线性独立性。

- **异或的性质：** 由于异或的结合性和交换性，我们可以按任意顺序处理基向量。

---

### 注意事项

- **位宽设置**：在处理整数时，要注意设置合适的位宽。对于 32 位整数，`MAXL` 可以设为 32，对于 64 位整数，`MAXL` 设为 64。
- **数值范围**：在计算过程中，可能会遇到大数，使用 `long long` 来防止溢出。
- **特殊情况处理**：在求第 $k$ 小的异或和时，要注意 $k$ 的范围，避免越界。

---

### 总结

异或线性基是处理涉及异或运算问题的强大工具，通过构建线性基，可以高效地解决最大异或和、异或和计数、特定异或和求解等问题。掌握其原理和实现，对于算法竞赛和实际应用都有重要意义。