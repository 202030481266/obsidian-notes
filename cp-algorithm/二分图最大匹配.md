
### 二分图与二分图最大匹配

在图论中，**二分图**（Bipartite Graph）是一类特殊的图，能够将顶点集划分为两个互不相交的子集，使得每条边连接的两个顶点分别属于不同的子集。简单来说，在二分图中，顶点被分成两组，组内的顶点没有相互连接，只有跨组的顶点才会有边。

#### 一、二分图的定义

一个图 $G = (V, E)$ 被称为二分图，如果它的顶点集 $V$ 可以分为两个不相交的集合 $U$ 和 $W$，即 $V = U \cup W$ 且 $U \cap W = \emptyset$，并且图中的每条边 $(u, w) \in E$ 都满足 $u \in U, w \in W$。

### 二、二分图的最大匹配

**匹配**是指图中没有公共顶点的边的集合。在二分图中，匹配的目标是从 $U$ 和 $W$ 的顶点集合中尽可能多地配对，形成没有公共顶点的边集。**最大匹配**是指包含边数最多的匹配。

#### 应用场景

二分图最大匹配的应用非常广泛，常见场景包括：

- **任务分配问题**：假设有一群工人和一群任务，每个工人只能执行特定的任务，如何将任务分配给工人，使得完成任务的工人数最多？
- **约会问题**：在一个约会场景中，如何找到最多的互相有好感的配对？
- **网络流问题**：二分图最大匹配还与最大流问题密切相关，可以通过构造网络流模型求解最大匹配。

#### 三、匈牙利算法求解最大匹配

求解二分图最大匹配的一种经典算法是**匈牙利算法**。匈牙利算法的核心思想是通过不断寻找**增广路径**，来扩大当前的匹配集。所谓增广路径，是指一条交替边的路径，其中匹配边和非匹配边交替出现，且起点和终点都是未匹配的顶点。

1. 初始化匹配集为空；
2. 从未匹配的顶点出发，寻找增广路径；
3. 如果找到了增广路径，就可以通过交换路径上的匹配边和非匹配边来扩大匹配集；
4. 重复此过程，直到找不到增广路径为止，此时的匹配集就是最大匹配。

#### 四、实现代码（C++）

下面我们用 C++ 实现一个求解二分图最大匹配的例子，使用匈牙利算法。

```cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

const int MAXN = 500;  // 最大顶点数量
vector<int> adj[MAXN]; // 邻接表表示二分图
int match[MAXN];       // 记录每个右边集合的匹配点
bool visited[MAXN];    // 用于DFS时记录访问状态

// 尝试为u寻找匹配
bool dfs(int u) {
    for (int v : adj[u]) {
        if (!visited[v]) {
            visited[v] = true;
            // 如果v没有被匹配过，或者v的匹配点可以找到其他匹配
            if (match[v] == -1 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

// 匈牙利算法求解最大匹配
int hungarian(int n) {
    int res = 0;
    memset(match, -1, sizeof(match)); // 初始化所有右边点都未匹配
    for (int u = 0; u < n; ++u) {
        memset(visited, false, sizeof(visited)); // 每次寻找增广路径时重置访问状态
        if (dfs(u)) {
            res++; // 找到一个新的匹配
        }
    }
    return res;
}

int main() {
    int n, m, u, v;
    cout << "输入顶点数和边数：" << endl;
    cin >> n >> m;  // 输入左边集合的顶点数 n 和边数 m
    cout << "输入每条边的两个端点：" << endl;
    for (int i = 0; i < m; ++i) {
        cin >> u >> v;  // u 属于左边集合，v 属于右边集合
        adj[u].push_back(v); // 记录二分图的边
    }

    int maxMatch = hungarian(n);
    cout << "最大匹配数为：" << maxMatch << endl;
    
    return 0;
}
```

#### 代码解释

1. **邻接表表示图结构**：`adj[u]` 用来存储左集合顶点 $u$ 与右集合顶点的连接关系。
2. **匈牙利算法**：我们通过深度优先搜索 (DFS) 来寻找增广路径。在每次匹配过程中，尝试为当前左集合顶点找到未匹配的右集合顶点，或者将右集合顶点的现有匹配重新匹配到其他顶点。
3. **最大匹配计数**：每找到一条增广路径，匹配数增加。

#### 五、复杂度分析

匈牙利算法的时间复杂度是 $O(V \times E)$，其中 $V$ 是左集合的顶点数，$E$ 是边数。对于大规模二分图，这种算法的性能通常是可接受的。

#### 六、总结

二分图最大匹配问题是一类非常经典的组合优化问题，广泛应用于任务分配、资源调度、配对等场景。匈牙利算法通过寻找增广路径来逐步扩展匹配，最终得到最大匹配。