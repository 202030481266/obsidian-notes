
### 二分图与二分图最大匹配

在图论中，**二分图**（Bipartite Graph）是一类特殊的图，能够将顶点集划分为两个互不相交的子集，使得每条边连接的两个顶点分别属于不同的子集。简单来说，在二分图中，顶点被分成两组，组内的顶点没有相互连接，只有跨组的顶点才会有边。

#### 一、二分图的定义

一个图 $G = (V, E)$ 被称为二分图，如果它的顶点集 $V$ 可以分为两个不相交的集合 $U$ 和 $W$，即 $V = U \cup W$ 且 $U \cap W = \emptyset$，并且图中的每条边 $(u, w) \in E$ 都满足 $u \in U, w \in W$。

### 二、二分图的最大匹配

**匹配**是指图中没有公共顶点的边的集合。在二分图中，匹配的目标是从 $U$ 和 $W$ 的顶点集合中尽可能多地配对，形成没有公共顶点的边集。**最大匹配**是指包含边数最多的匹配。

#### 应用场景

二分图最大匹配的应用非常广泛，常见场景包括：

- **任务分配问题**：假设有一群工人和一群任务，每个工人只能执行特定的任务，如何将任务分配给工人，使得完成任务的工人数最多？
- **约会问题**：在一个约会场景中，如何找到最多的互相有好感的配对？
- **网络流问题**：二分图最大匹配还与最大流问题密切相关，可以通过构造网络流模型求解最大匹配。

#### 三、匈牙利算法求解最大匹配

求解二分图最大匹配的一种经典算法是**匈牙利算法**。匈牙利算法的核心思想是通过不断寻找**增广路径**，来扩大当前的匹配集。所谓增广路径，是指一条交替边的路径，其中匹配边和非匹配边交替出现，且起点和终点都是未匹配的顶点。

1. 初始化匹配集为空；
2. 从未匹配的顶点出发，寻找增广路径；
3. 如果找到了增广路径，就可以通过交换路径上的匹配边和非匹配边来扩大匹配集；
4. 重复此过程，直到找不到增广路径为止，此时的匹配集就是最大匹配。

#### 四、实现代码（C++）

下面我们用 C++ 实现一个求解二分图最大匹配的例子，使用匈牙利算法。

```cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

const int MAXN = 500;  // 最大顶点数量
vector<int> adj[MAXN]; // 邻接表表示二分图
int match[MAXN];       // 记录每个右边集合的匹配点
bool visited[MAXN];    // 用于DFS时记录访问状态

// 尝试为u寻找匹配
bool dfs(int u) {
    for (int v : adj[u]) {
        if (!visited[v]) {
            visited[v] = true;
            // 如果v没有被匹配过，或者v的匹配点可以找到其他匹配
            if (match[v] == -1 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

// 匈牙利算法求解最大匹配
int hungarian(int n) {
    int res = 0;
    memset(match, -1, sizeof(match)); // 初始化所有右边点都未匹配
    for (int u = 0; u < n; ++u) {
        memset(visited, false, sizeof(visited)); // 每次寻找增广路径时重置访问状态
        if (dfs(u)) {
            res++; // 找到一个新的匹配
        }
    }
    return res;
}

int main() {
    int n, m, u, v;
    cout << "输入顶点数和边数：" << endl;
    cin >> n >> m;  // 输入左边集合的顶点数 n 和边数 m
    cout << "输入每条边的两个端点：" << endl;
    for (int i = 0; i < m; ++i) {
        cin >> u >> v;  // u 属于左边集合，v 属于右边集合
        adj[u].push_back(v); // 记录二分图的边
    }

    int maxMatch = hungarian(n);
    cout << "最大匹配数为：" << maxMatch << endl;
    
    return 0;
}
```

#### 代码解释

1. **邻接表表示图结构**：`adj[u]` 用来存储左集合顶点 $u$ 与右集合顶点的连接关系。
2. **匈牙利算法**：我们通过深度优先搜索 (DFS) 来寻找增广路径。在每次匹配过程中，尝试为当前左集合顶点找到未匹配的右集合顶点，或者将右集合顶点的现有匹配重新匹配到其他顶点。
3. **最大匹配计数**：每找到一条增广路径，匹配数增加。

#### 五、复杂度分析

匈牙利算法的时间复杂度是 $O(V \times E)$，其中 $V$ 是左集合的顶点数，$E$ 是边数。对于大规模二分图，这种算法的性能通常是可接受的。

#### 六、总结

二分图最大匹配问题是一类非常经典的组合优化问题，广泛应用于任务分配、资源调度、配对等场景。匈牙利算法通过寻找增广路径来逐步扩展匹配，最终得到最大匹配。

---
## Hopcroft-Karp算法

Hopcroft-Karp算法是更加高级的二分图匹配算法，其中核心在于多路增广。在Hopcroft-Karp算法中，**多路增广**（即在每个阶段同时增广所有最短增广路）能够将增广次数限制在 $O(\sqrt{n})$ 级别，这是因为该算法巧妙地利用了增广路的长度增长特性，以及增广路径之间的相互独立性。

以下是对这一现象的详细解释：

1. **增广路径的长度递增：**

   - 在Hopcroft-Karp算法的每个阶段，我们使用广度优先搜索（BFS）来寻找所有**最短增广路径**。
   - 当我们沿这些最短增广路径进行增广后，这些路径被破坏，导致下一阶段的最短增广路径长度至少增加2（因为在二分图中，增广路径的长度总是奇数）。
   - 由于增广路径的长度每次至少增加2，而增广路径的最大可能长度不超过 $2n$，因此最多只能有 $O(\sqrt{n})$ 个这样的长度增加阶段。

2. **每个阶段的多路增广：**

   - 在每个阶段，我们不仅找到一条增广路径，而是找到所有的最短增广路径，并同时沿这些路径进行增广。
   - 由于这些最短增广路径是顶点不相交的（即彼此独立），我们可以在一个阶段中同时增大匹配的大小，避免了逐一增广带来的效率低下。

3. **对增广次数的影响：**

   - 因为每个阶段都尽可能多地增广匹配，而且阶段的总数被限制在 $O(\sqrt{n})$ 级别，所以总的增广次数也被限制在 $O(\sqrt{n})$。
   - 这比朴素的逐一增广方法（可能需要 $O(n)$ 次增广）效率高得多。

4. **理解方式：**

   - **路径长度与增广能力的平衡**：随着匹配的增大，剩余的增广路径会变得更长，找到它们也更困难。但是，通过在每个阶段同时处理所有最短增广路径，我们最大化了每个阶段的增广效果。
   - **顶点的“分层”结构**：广度优先搜索建立了一个分层网络，每一层代表距离未匹配顶点的距离。随着层数的增加，可用于增广的顶点数目减少，这自然限制了阶段的总数。

5. **数学分析：**

   - 可以证明，每个阶段增广的路径数与增广路径的长度成反比。具体来说，如果增广路径的长度为 $l$，那么顶点不相交的最短增广路径的数量至多为 $O\left(\dfrac{n}{l}\right)$。
   - 由于增广路径的长度每次增加，且总的顶点数为 $n$，通过求和可以得出总的增广次数为 $O(\sqrt{n})$。

**总结：**

多路增广策略通过在每个阶段最大限度地利用当前可用的最短增广路径，并随着匹配的增长逐步增加增广路径的长度，从而有效地限制了增广次数。这样，Hopcroft-Karp算法能够在 $O(\sqrt{n})$ 个阶段内找到最大匹配，显著提高了算法的效率。

---

### Hopcroft-Karp 算法概述

Hopcroft-Karp 算法用于在二分图中找到最大匹配。它通过以下步骤实现高效的匹配：

1. **广度优先搜索（BFS）分层：**构建一个分层网络，找到所有最短增广路径的结构。
2. **深度优先搜索（DFS）寻找增广路径：**在分层网络中寻找所有最短增广路径。
3. **多路增广：**同时沿所有找到的最短增广路径增广匹配。

通过在每个阶段同时处理所有最短增广路径，算法有效地限制了阶段的总数，从而将总的增广次数限制在 $O(\sqrt{n})$ 的级别。

### 详细步骤

#### 1. 初始化

- **匹配初始化：** 开始时，匹配 $M$ 为空。
- **图的表示：** 使用邻接表或邻接矩阵表示二分图。

#### 2. 广度优先搜索（BFS）分层

- **目的：** 找到从未匹配的左部顶点开始的所有最短增广路径的层次结构。
- **过程：**
  - 将所有未匹配的左部顶点加入 BFS 队列，距离设为 0。
  - 对于每个顶点，根据匹配状态和边的方向更新其邻居的距离。
  - 只考虑可以成为增广路径一部分的边。

#### 3. 深度优先搜索（DFS）寻找增广路径

- **目的：** 在分层网络中寻找所有从未匹配的左部顶点到未匹配的右部顶点的最短增广路径。
- **过程：**
  - 从未匹配的左部顶点开始 DFS。
  - 只沿着满足层次条件的边进行搜索。
  - 当到达未匹配的右部顶点时，记录增广路径并更新匹配。

#### 4. 多路增广

- **过程：**
  - 对于每条找到的增广路径，翻转路径上的匹配边和未匹配边。
  - 更新匹配 $M$。

#### 5. 重复步骤 2-4

- **终止条件：** 当 BFS 无法找到新的增广路径（即没有新的层次结构）时，算法终止。

---

### 示例说明

考虑一个二分图，左部顶点集合为 $U = \{ u_1, u_2, u_3, u_4, u_5 \}$，右部顶点集合为 $V = \{ v_1, v_2, v_3, v_4, v_5 \}$，边集 $E$ 如下：

- $u_1$ 连接 $v_1, v_2$
- $u_2$ 连接 $v_2, v_3$
- $u_3$ 连接 $v_1, v_3, v_4$
- $u_4$ 连接 $v_4, v_5$
- $u_5$ 连接 $v_5$

**初始匹配：** 开始时匹配为空。

**第一次 BFS 分层：**

- **层次 0（左部未匹配顶点）：**$u_1, u_2, u_3, u_4, u_5$
- **层次 1（右部顶点）：**
  - $u_1$ 的邻居：$v_1, v_2$
  - $u_2$ 的邻居：$v_2, v_3$
  - $u_3$ 的邻居：$v_1, v_3, v_4$
  - $u_4$ 的邻居：$v_4, v_5$
  - $u_5$ 的邻居：$v_5$
- **层次 1 包含的顶点：**$v_1, v_2, v_3, v_4, v_5$

**第一次 DFS 寻找增广路径：**

- 从 $u_1$ 开始：
  - $u_1 - v_1$（未匹配），找到增广路径 $u_1 - v_1$
- 从 $u_2$ 开始：
  - $u_2 - v_2$（未匹配），找到增广路径 $u_2 - v_2$
- 从 $u_3$ 开始：
  - $u_3 - v_3$（未匹配），找到增广路径 $u_3 - v_3$
- 从 $u_4$ 开始：
  - $u_4 - v_4$（未匹配），找到增广路径 $u_4 - v_4$
- 从 $u_5$ 开始：
  - $u_5 - v_5$（未匹配），找到增广路径 $u_5 - v_5$

**更新匹配：**

- 匹配对为：
  - $(u_1, v_1)$
  - $(u_2, v_2)$
  - $(u_3, v_3)$
  - $(u_4, v_4)$
  - $(u_5, v_5)$

**第二次 BFS 分层：**

- 所有左部顶点均已匹配，无未匹配的左部顶点，算法终止。

---

### C++ 代码实现

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits.h>

using namespace std;

class HopcroftKarp {
public:
    int n, m; // 左、右部顶点数量
    vector<vector<int>> adj; // 邻接表
    vector<int> pairU, pairV, dist; // 匹配对和距离

    HopcroftKarp(int n, int m) : n(n), m(m), adj(n + 1) {
        pairU.assign(n + 1, 0);
        pairV.assign(m + 1, 0);
        dist.assign(n + 1, 0);
    }

    // 添加边，u 属于左部 [1, n]，v 属于右部 [1, m]
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    // BFS 分层
    bool bfs() {
        queue<int> Q;
        for (int u = 1; u <= n; ++u) {
            if (pairU[u] == 0) {
                dist[u] = 0;
                Q.push(u);
            } else {
                dist[u] = INT_MAX;
            }
        }
        dist[0] = INT_MAX;

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            if (dist[u] < dist[0]) {
                for (int v : adj[u]) {
                    if (dist[pairV[v]] == INT_MAX) {
                        dist[pairV[v]] = dist[u] + 1;
                        Q.push(pairV[v]);
                    }
                }
            }
        }
        return dist[0] != INT_MAX;
    }

    // DFS 寻找增广路径
    bool dfs(int u) {
        if (u != 0) {
            for (int v : adj[u]) {
                if (dist[pairV[v]] == dist[u] + 1) {
                    if (dfs(pairV[v])) {
                        pairU[u] = v;
                        pairV[v] = u;
                        return true;
                    }
                }
            }
            dist[u] = INT_MAX;
            return false;
        }
        return true;
    }

    // 主函数，计算最大匹配
    int maxMatching() {
        int matching = 0;
        while (bfs()) {
            for (int u = 1; u <= n; ++u) {
                if (pairU[u] == 0 && dfs(u)) {
                    matching++;
                }
            }
        }
        return matching;
    }
};

int main() {
    int n = 5; // 左部顶点数量
    int m = 5; // 右部顶点数量
    HopcroftKarp hk(n, m);

    // 添加边
    hk.addEdge(1, 1);
    hk.addEdge(1, 2);
    hk.addEdge(2, 2);
    hk.addEdge(2, 3);
    hk.addEdge(3, 1);
    hk.addEdge(3, 3);
    hk.addEdge(3, 4);
    hk.addEdge(4, 4);
    hk.addEdge(4, 5);
    hk.addEdge(5, 5);

    int result = hk.maxMatching();
    cout << "最大匹配数为：" << result << endl;

    // 输出匹配结果
    for (int u = 1; u <= n; ++u) {
        if (hk.pairU[u] != 0) {
            cout << "左部顶点 " << u << " 匹配到右部顶点 " << hk.pairU[u] << endl;
        }
    }

    return 0;
}
```

---

### 代码解释

#### 数据结构

- **`adj`：** 邻接表，`adj[u]` 存储左部顶点 `u` 的所有邻接右部顶点。
- **`pairU` 和 `pairV`：** 匹配对，`pairU[u]` 表示左部顶点 `u` 匹配的右部顶点，`pairV[v]` 表示右部顶点 `v` 匹配的左部顶点。
- **`dist`：** 距离数组，记录 BFS 分层时顶点的距离。

#### 主要函数

- **`addEdge(u, v)`：** 添加从左部顶点 `u` 到右部顶点 `v` 的边。
- **`bfs()`：** 执行 BFS 分层，构建层次结构。
  - 初始化所有未匹配的左部顶点的距离为 0。
  - 使用队列进行 BFS，更新邻接顶点的距离。
  - 返回是否存在增广路径。
- **`dfs(u)`：** 在分层网络中执行 DFS 寻找增广路径。
  - 递归地寻找未匹配的右部顶点。
  - 如果找到增广路径，更新匹配对 `pairU` 和 `pairV`。
- **`maxMatching()`：** 主函数，计算最大匹配数。
  - 不断重复 BFS 和 DFS，直到没有新的增广路径。

#### 运行结果

对于上述示例，程序将输出：

```
最大匹配数为：5
左部顶点 1 匹配到右部顶点 1
左部顶点 2 匹配到右部顶点 2
左部顶点 3 匹配到右部顶点 3
左部顶点 4 匹配到右部顶点 4
左部顶点 5 匹配到右部顶点 5
```

---

我发现HK算法一开始非常难以理解，哪怕学习了很多次了，我依然觉得这个算法不简单。所有下面是我总结的终极奥义。

### 本质是增广路

再次回顾一下最简单的增广路知识点。

首先就是增广路总是从一个没有匹配的点出发，然后结束于一个没有匹配的点的交错路径。那么很显然，一个点最多只会被任意一条增广路增广一次，增广结束后就不能从这个点出发了，所以在进行增广路算法的时候，对于每一个点只需要枚举一次。

**这个增广路算法在二分图中表现就是匈牙利算法**。在这个算法中，我们总是从一个没有配对的左边的点$u$出发，尝试匹配相邻的点$v$，如果$match[v]$能够顺利找到另外的点配对，则说明这个配对$<u,v>$是合法的。大概意思长这样，在$dfs$的过程中会产生一个交错树。

比如我们有这么一个图：

![[HK augment path 1.svg#center]]

我们可以尝试从1开始寻找，就可以形成一个交错树：

![[HK augment path 2.svg#center]]

可以看到，$1\rightarrow 12$是一条合法的增广路径。

### HK算法的核心是分层

HK算法依然依赖于增广路算法，但是HK算法进行了一个多路增广的优化，这个思想非常巧妙。首先对于经典的增广路算法，我们可以想到一个问题：**增广路的条数于增广路的长度的关系**。增广路最长为$|E|$，但是这个时候增广路就只有一条。如果增广路有$\frac{|V|}{2}$条，那么必然增广路的长度就是1。可以发现一点就是，增广路的条数与增广路的长度之间存在乘积的关系。所以我们不妨尝试从长度入手多路寻找增广路，如果要使得增广路算法复杂度最高，那么只能是$\sqrt{|V|}$ 级别的。这是HK算法的高效的一个最为关键的洞察。

在经典的DFS算法中，我们允许了增广路的寻找是可以任何顺序的，但是在HK算法中，我们加上了一个顺序，就是当节点只有满足距离关系$d[u]+1=d[match[v]]$，才会继续搜索$match[v]$，这是一个强大的限制，这表示我们永远在寻找关于节点$u$的最短增广路。

![[HK 增广路 BFS树.drawio.svg#center]]

从上面的图片就可以看出这个分层是一种交错路径的BFS树，而且如果$v$配对了一个节点$u$，那么和$u$同层的节点不可能再配对上$v$，这就使得整体的寻找的增广路径一定是互不相交的，中间节点不会存在相同的情况。（非常巧妙，网络流算法Dinic也是同样的原理）

### 代码实现

下面是一个更加好用的简洁的代码模板：

```cpp
struct HopcroftKarp
{
    static const int inf = 1e9;
    int n;
    vector<int> l, r, d;
    vector<vector<int>> g;
    HopcroftKarp(int _n, int _m)
    {
        n = _n;
        int p = _n + _m + 1;
        g.resize(p);
        l.resize(p, 0);
        r.resize(p, 0);
        d.resize(p, 0);
    }
    void add_edge(int u, int v)
    {
        g[u].push_back(v + n); //right id is increased by n, so is l[u]
    }
    bool bfs()
    {
        queue<int> q;
        for (int u = 1; u <= n; u++)
        {
            if (!l[u]) d[u] = 0, q.push(u);
            else d[u] = inf;
        }
        d[0] = inf;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            for (auto v : g[u])
            {
                if (d[r[v]] == inf)
                {
                    d[r[v]] = d[u] + 1;
                    q.push(r[v]);
                }
            }
        }
        return d[0] != inf;
    }
    bool dfs(int u)
    {
        if (!u) return true;
        for (auto v : g[u])
        {
            if(d[r[v]] == d[u] + 1 && dfs(r[v]))
            {
                l[u] = v;
                r[v] = u;
                return true;
            }
        }
        d[u] = inf;
        return false;
    }
    int maximum_matching()
    {
        int ans = 0;
        while (bfs())
        {
            for(int u = 1; u <= n; u++) if (!l[u] && dfs(u)) ans++;
        }
        return ans;
    }
};
int32_t main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int n, m, q;
    cin >> n >> m >> q;
    HopcroftKarp M(n, m);
    while (q--)
    {
        int u, v;
        cin >> u >> v;
        M.add_edge(u, v);
    }
    cout << M.maximum_matching() << '\n';
    return 0;
}
```