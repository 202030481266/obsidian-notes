
# 同余分组

同余最短路的本质思想其实还是同余分组。这个在单调队列优化背包就已经使用到了这个思想了，如果说一个问题的答案集合可以和某一个同余分组相关联，那么这个时候就可以使用同余分组来建模，这样的好处在于，如果基准值很小，那么组的空间就会很低。而同余最短路算法就是在这些组之间构建联系，于是就继承了图算法的一切强大。这个算法主要难点在于建模，下面是一些经典的问题和解决思路。（主要还是锻炼建模思维，要求做题比较多）

---
## **1. 周期性事件的调度问题**

### **应用场景**

- **公共交通调度**：公交车、地铁等交通工具按照固定的时间间隔发车，乘客需要规划最短的出行时间。
- **工厂生产线**：机器设备需要定期维护，生产过程需要在维护周期内完成任务。
- **网络数据包发送**：数据包在网络中按照固定的时间间隔发送，需要在特定的时间窗口内传输数据。

### **建模方法**

- **状态定义**：将节点状态扩展为 (位置，时间余数)，即 $(u, t\ mod\ m)$，其中$m$是周期长度。
- **状态转移**：在遍历边时，更新时间余数，考虑等待时间或延迟。
- **目标**：找到满足时间同余条件的最短路径，使得到达终点的总时间最少。

### **示例**

- **公交车问题**：公交车每10分钟一班，乘客在某个时间到达车站，需要规划到达目的地的最短时间。
  - **建模**：使用同余最短路算法，状态为 (站点，时间 mod 10)，在状态转移时考虑等待时间。

---

## **2. 路径长度或费用的同余约束**

### **应用场景**

- **密码学中的密钥传输**：需要找到一条路径，使得传输的总费用满足特定的同余条件，以满足安全要求。
- **物流配送**：货物运输需要在路径长度或费用上满足某种同余限制，比如总重量必须是某个数的倍数。

### **建模方法**

- **状态定义**：将节点状态定义为 (位置，累积费用 mod m)。
- **状态转移**：在遍历边时，更新累积费用的余数 $(k + w)\ mod\ m$。
- **目标**：找到一条从起点到终点的路径，使得总费用满足特定的同余条件。

### **示例**

- **加油站问题**：车辆在行驶过程中，需要使总行驶距离是油箱容量的倍数，以方便加油。
  - **建模**：状态为 (位置，距离 mod 油箱容量)，使用同余最短路算法规划路径。

---

## **3. 资源刷新或重置的系统**

### **应用场景**

- **游戏中的技能冷却**：角色技能有冷却时间，需要规划技能释放的最佳时机。
- **缓存系统**：缓存数据有过期时间，需要在数据过期前完成相关操作。
- **电池充电周期**：设备电池需要定期充电，任务需要在电池耗尽前完成。

### **建模方法**

- **状态定义**：将节点状态定义为 (位置，资源状态 mod m)，如 (u, 能量余量 mod m)。
- **状态转移**：在遍历边时，消耗资源并更新资源余量的同余类。
- **目标**：确保在资源耗尽或刷新前，任务能够完成。

### **示例**

- **技能释放规划**：在游戏地图中移动，规划技能的释放，使得在关键位置能够使用技能。
  - **建模**：状态为 (位置，技能冷却时间 mod 技能冷却周期)，使用同余最短路算法确定移动路径和技能释放时机。

---

## **4. 限时开放的道路或通道**

### **应用场景**

- **限时桥梁或隧道**：某些桥梁只在特定时间开放，需要在开放时间内通过。
- **安保系统**：门禁系统在固定的时间段允许通行，需要在指定时间内进入。

### **建模方法**

- **状态定义**： (位置，当前时间 mod 开放周期)。
- **状态转移**：考虑等待时间，使得在通道开放时到达。
- **目标**：最小化总时间，满足通道的开放时间约束。

### **示例**

- **河流渡口问题**：渡船每隔一定时间来回，需要规划到达渡口的时间，以最小化等待时间。
  - **建模**：状态为 (渡口，时间 mod 渡船周期)，在状态转移时计算等待时间。

---

## **5. 循环赛程或重复任务规划**

### **应用场景**

- **体育赛事安排**：球队在循环赛中对战，需要安排赛程，使得休息时间满足特定条件。
- **生产线任务调度**：重复性的任务需要在周期内完成，且满足资源或时间的同余约束。

### **建模方法**

- **状态定义**： (任务节点，累计周期数 mod m)。
- **状态转移**：在任务之间转移时，更新周期数的余数。
- **目标**：安排任务顺序，满足同余约束，优化整体效率。

### **示例**

- **循环赛赛程安排**：规划球队比赛顺序，使得每支球队的比赛间隔满足特定的同余条件，避免过长或过短的休息时间。
  - **建模**：状态为 (球队，比赛轮次 mod 休息周期)，使用同余最短路算法安排赛程。

---

## **6. 数论中的路径问题**

### **应用场景**

- **求解同余方程**：在图中寻找路径，使得累积的权值满足某个同余方程。
- **模运算优化**：在算法中，需要控制累积结果的模值，以避免溢出或满足特定条件。

### **建模方法**

- **状态定义**： (节点，累积值 mod m)。
- **状态转移**：按照边权值更新累积值的同余类。
- **目标**：找到满足同余方程的路径。

### **示例**

- **加权路径同余问题**：在加权图中，寻找一条路径，使得路径权值之和 mod m 等于给定值r。
  - **建模**：状态为 (节点，累积权值 mod m)，使用同余最短路算法搜索。

---

## **7. 特殊移动规则的棋盘或游戏**

### **应用场景**

- **棋盘游戏**：棋子按照特定的移动规则移动，需要在步数或位置上满足同余条件。
- **迷宫寻宝**：需要在迷宫中按照特定的步数到达宝藏位置，步数满足同余约束。

### **建模方法**

- **状态定义**： (位置，步数 mod m)。
- **状态转移**：每次移动更新步数的余数。
- **目标**：找到满足步数同余条件的路径。

### **示例**

- **跳马问题**：在国际象棋的棋盘上，马按照规则移动，需要在步数为某个数的倍数时到达目标位置。
  - **建模**：状态为 (棋盘位置，步数 mod m)，使用同余最短路算法寻找路径。

---

## **总结**

**同余最短路算法在解决具有周期性、模数约束的最短路径问题时非常有效**。通过对状态进行同余分组，我们可以：

- **精确控制**累积量（如时间、费用、资源）的同余性质。
- **满足特定约束**，如在特定时间到达、累积值满足同余方程等。
- **优化效率**，避免重复计算，确保算法的高效性。

在建模时，关键步骤包括：

1. **扩展状态空间**：将原始状态与同余信息结合，形成新的状态。
2. **设计状态转移**：在遍历过程中正确更新同余信息。
3. **选择合适的算法**：根据边权特性，选择Dijkstra、Bellman-Ford等算法，并结合优先队列优化。

通过熟练应用同余最短路算法，您可以解决各种涉及同余约束的最短路径问题，这在算法竞赛和实际应用中都具有重要意义。

---

## 题目1 - 跳楼机

一座大楼一共有$h$层，楼层编号$1 \sim h$，有如下四种移动方式：
1. 向上移动$x$层
2. 向上移动$y$层
3. 向上移动$z$层
4. 回到1层

假设你正在第1层，请问大楼里有多少楼层你可以到达。

条件：
$$
\begin{align}
&1 \leq h \leq 2^{63} - 1 \\
&1 \leq x, y, z \leq 10^5
\end{align}
$$

测试链接：[https://www.luogu.com.cn/problem/P3403](https://www.luogu.com.cn/problem/P3403)

**解法：Dijkstra算法实现同余最短路**

---

## 题目2 - 牛场围栏

给定一个长度为$n$的数组$arr$，$arr[i]$代表第$i$种木棍的长度，每种木棍有无穷多个。给定一个正数$m$，表示你可以把任何一根木棍消去最多$m$的长度，同一种木棍可以消去不同的长度。你可以随意拼接木棍形成一个长度，返回不能拼出来的长度中，最大值是多少。如果你可以拼出任何长度，返回-1；如果不能拼出来的长度有无穷多，返回-1。

条件：
$$
\begin{align}
&1 \leq n \leq 100 \\
&1 \leq arr[i] \leq 3000 \\
&1 \leq m \leq 3000
\end{align}
$$

测试链接：[https://www.luogu.com.cn/problem/P2662](https://www.luogu.com.cn/problem/P2662)

**解法：Dijkstra算法实现同余最短路**

---

## 题目3 - 正整数倍的最小数位和

给定一个整数$k$，求一个$k$的正整数倍$s$，使得在十进制下，$s$的数位累加和最小。不返回$s$，而是返回这个最小的数位和。

条件：
$$
2 \leq k \leq 10^5
$$

测试链接：
- [https://www.luogu.com.cn/problem/AT_arc084_b](https://www.luogu.com.cn/problem/AT_arc084_b)
- [https://atcoder.jp/contests/abc077/tasks/arc084_b](https://atcoder.jp/contests/abc077/tasks/arc084_b)

**解法：巧妙构造 + 01bfs算法实现同余最短路**

---

## 题目4 - 墨墨的等式

一共有$n$种正数，每种数可以选择任意个，个数不能是负数。那么一定有某些数值可以由这些数字累加得到。请问在$[l...r]$范围上，有多少个数能被累加得到。

条件：
$$
\begin{align}
&0 \leq n \leq 12 \\
&0 \leq 数值范围 \leq 5 \times 10^5 \\
&1 \leq l \leq r \leq 10^{12}
\end{align}
$$

测试链接：[https://www.luogu.com.cn/problem/P2371](https://www.luogu.com.cn/problem/P2371)

**解法1：Dijkstra算法实现同余最短路**  
**解法2：两次转圈法实现同余最短路**

---

## 两次转圈法实现同余最短路

给定一个基准数$x$，那么可能的余数为$0 \dots x-1$。假设当前余数是$cur$，当前出现数字为$y$，$(cur + y) \% x$所出现的新余数，最终会回到$cur$。当前出现数字为$y$，$0 \dots x-1$这些点，会形成$\gcd(x, y)$个子环，所有子环的起点为：$0 \sim \gcd(x, y) - 1$。每个子环为单位，进行同余最短路的更新，所有子环的所有点的数量 = $x$，即更新一轮的代价$O(x)$。

因为是最短路，所以每出现一个新的数字$y$，所形成的每个子环，只需要转一圈即可完成更新。特别注意：子环的起点不一定是点权最小的点，所以实现中，往往用转两圈的方式。

如果一共有$n$个数字，基准数为$x$，那么同余最短路的更新代价为$O(n \times x)$。SPFA算法也可以实现同余最短路的更新，但是比赛中经常设计数据，让其时间复杂度高于$O(n \times x)$，为了顺利通过，所以更推荐两次绕圈法。

---

## 题目5 - 背包

一共有$n$种物品，第$i$种物品的体积为$v[i]$，价值为$c[i]$，每种物品可以选择任意个，个数不能是负数。一共有$m$条查询，每次查询都会给定$jobv$，代表体积的要求。要求挑选物品的体积和一定要严格是$jobv$，返回能得到的最大价值和。如果没有方案能正好凑满$jobv$，返回-1。

条件：
$$
\begin{align}
&1 \leq n \leq 50 \\
&1 \leq m \leq 10^5 \\
&1 \leq v[i] \leq 10^5 \\
&1 \leq c[i] \leq 10^6 \\
&10^{11} \leq jobv \leq 10^{12}
\end{align}
$$

测试链接：[https://www.luogu.com.cn/problem/P9140](https://www.luogu.com.cn/problem/P9140)

**解法：贪心决定基准物品 + 数据范围分析 + 两次转圈法实现同余最长路**


---

## 一个观察到的有趣猜想

- **给定条件：**

  - 一个正整数 $p \geq 2$（不一定是质数）。
  - 一组整数 $S = \{x_1, x_2, \dots, x_n\}$，其中每个 $x_i \in [0, p-1]$。
  - 任意起点 $a \in \mathbb{Z}_p$。
  - 目标数 $b \in \mathbb{Z}_p$。

- **操作规则：**

  - 从 $a$ 出发，每次可以选择任意一个 $x_i$，将其加到当前值上，然后对 $p$ 取模。
  - 可以重复使用 $x_i$，每次加法算作一步操作。

- **假设：**

  - 对于任意的 $a$ 和 $b$，通过上述操作总能从 $a$ 到达 $b$。

- **猜想：**

  - 达到目标数 $b$ 所需的最少加法次数 $N(a, b)$ 满足：
  $$
    N(a, b) \leq p
    $$
  - 即，无论起点和终点是什么，最小加法次数不超过 $p$。

**进一步说明：**

- **单一元素的情况：**

  - 如果只有一个元素 $x = 1$，则每次只能前进 1 个单位。
  - 从 $a$ 到 $b$ 最多需要 $p - 1$ 次加法，因为在模 $p$ 的空间中，经过 $p$ 次加法会回到原点。

- **多个元素的情况：**

  - 如果 $S$ 中有多个元素，且其中至少有一个元素与 $p$ 互质，那么可能通过更少的加法次数达到 $b$。
  - 元素之间的组合可以使每次加法前进更大的步长。

- **关键因素：**

  - 元素集合 $S$ 能否生成模 $p$ 下的所有元素。
  - 元素 $x_i$ 是否与 $p$ 互质，这影响了可到达的余数和最小加法次数。

**结论：**

- 猜想认为，在上述条件和操作下，从任意起点 $a$ 到任意目标 $b$，所需的最少加法次数 $N(a, b)$ 总是满足：
  $$
  N(a, b) \leq p
  $$
- 这意味着，无论元素集合 $S$ 是什么，只要能够从 $a$ 到达 $b$，所需的最小加法次数不会超过 $p$。