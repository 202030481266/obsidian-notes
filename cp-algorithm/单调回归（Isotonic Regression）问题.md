# 问题和基本解法

## 转换

给定一个数组 $A = (A[0], A[1], \ldots, A[n-1])$，我们想要找到一个递增序列 $B = (B[0], B[1], \ldots, B[n-1])$ 来最小化  
$$
\sum_{i=0}^{n-1} |A[i] - B[i]|.
$$

这个问题属于「带单调性约束的最优拟合问题」，通常称为等距序列上的「L1等距回归」或「单调回归」(Isotonic Regression)。

可以发现其中的关键约束条件是 $B[0] < B[1] < \cdots < B[n-1]$。  

如果我们定义新序列 $C[i] = A[i] - i$，同时定义 $D[i] = B[i] - i$，则非降条件对于 $B$ 等价于对 $D$ 而言：  
$$
B[i] \leq B[i+1] \iff B[i] - i \leq B[i+1] - (i+1) \iff D[i] \leq D[i+1].
$$

因此，$D$ 必须是一个非降序列。

对于目标函数，有：  
$$
\sum_{i=0}^{n-1} |A[i] - B[i]| = \sum_{i=0}^{n-1} |(A[i] - i) - (B[i] - i)| = \sum_{i=0}^{n-1} |C[i] - D[i]|.
$$

由此，将原问题转化为： 

**在给定的序列 $C$ 下，寻找一个非降序列 $D$，以最小化 $\sum |C[i] - D[i]|$。**

这个问题是一个标准的「等距单调回归」问题，有多种成熟算法可以在 $O(n)$ 或 $O(n \log n)$ 时间内求出最优解 $D$。

求解出 $D$ 后，再根据 $B[i] = D[i] + i$ 即可得到最终的 $B$。

---
## PAVA算法

经典的「单调回归（Isotonic Regression）」问题存在高效的算法，而针对 $\sum |A[i] - B[i]|$ 最小化并要求 $B$ 非降的情形，有一个著名的线性时间算法，称为「Pool Adjacent Violators Algorithm（PAVA）」。（这是$L1$损失，实际上$L2$损失也行，而且实现更加简单）

### 基本思想

1. 将问题转化为 $C[i] = A[i] - i$ 的序列后，我们就要从 $C$ 中求一个非降序列 $D$，使 $\sum |C[i] - D[i]|$ 最小。
2. 为了满足单调性，我们从左到右扫描，并在出现违反单调性的地方合并相邻的块（blocks）。这里的块指一段连续元素，它们将在最终解中被设定为相同的值。
3. 每当合并两个（或多个）块时，为了使 $\sum |C[i] - D[i]|$ 最优，我们应将合并后的块赋值为这批元素的中位数（对于奇偶个数分别是中点或平均中点），因为中位数是最优的「绝对偏差」中心。通过这种方式，每次合并我们就能保证该片段的内部误差已最小化。
4. 在实现上，虽然要选中位数听起来需要高效的中位数维护数据结构（如堆或平衡树），但事实上 PAVA 的过程保证了我们只需用双端栈或列表合并区间，就可以在 $O(n)$ 的时间内完成整个等距单调回归过程。

如果上面的步骤看不懂，可以接着看，下面用相对通俗但仍较为形式化的方式来介绍 PAVA（Pool Adjacent Violators Algorithm）算法，并解释为什么这种贪心做法是正确的。
  
1. **初始状态**：  
   将每个元素视作独立的「块（block）」。也就是说，一开始有 $n$ 个块，每个块只包含一个元素 $C_i$，并暂时设 $D_i = C_i$。此时，序列 $D$ 是 trivially 非降序列吗？不一定。但现在我们还没正式处理非降约束，我们只是先把每个点当作一块。

2. **寻找并合并「相邻冲突」块**：  
   从左到右检查这些块。如果发现相邻两个块 $B_j, B_{j+1}$（各自包含一些连续的元素）出现「非降性违例（Adjacent Violators）」：  
   $$
   \text{块 } B_j \text{ 的值} > \text{块 } B_{j+1}\text{ 的值},
   $$  
   那么就将这两个块「合并」（pooling）成一个更大的块 $B_j'$。

   在合并后，新块 $B_j'$ 包含了原来两个块中的所有元素。要给这个新块一个统一的值，以使该块内部的  
   $\sum |C_i - D_i|$ 最小化。已知对于一组数，能使绝对偏差和最小的代表值是这组数的中位数（若元素数为偶数，可取任意中位点间的值）。因此，新合并的块取其中所有元素的中位数作为该块的值。

3. **重复合并直至满足非降性**：  
   合并之后可能会引发更早位置块的非降性冲突，因此需要往回回溯，检查新形成的块与其左邻块是否仍然符合非降性，如不符则继续合并。  
   当不再有相邻块出现「前块值大于后块值」的情况时，整个合并过程结束。

4. **输出结果**：  
   此时，所有块都满足：左边的块值不大于右边的块值。然后，对于各个块中包含的元素 $i$，定义 $D_i$ 为该块的统一值。这样得到的 $D$ 即为满足非降约束下使误差和最小的序列。
### 贪心策略的正确性

#### 局部最优性（Local Optimality）

在合并操作中，每当我们发现两个相邻块 $B_j$ 和 $B_{j+1}$ 违反非降约束（即前块的值大于后块的值），我们将它们合并成一个更大的块，并用中位数作为新值。  

对这两个块内部来说，把它们合并为一个块并采用合并后元素组的中位数值，一定不会比保持两个块分开时差。因为：  
- 如果块间存在顺序违例（前块值比后块值大），则当前解不是合法的非降解。
- 合并后选择中位数保证了合并后这部分整体的绝对偏差总和在给定这两个块所涉及的元素中已经达到最优（比原先两个块分别选自己中位数时的局部情况更佳或至少不差）。  

换句话说，每一次合并是将一个明显的「非可行点」修正到一个「局部最优可行段」，并且保证该局部优化对全局没有负面影响。

#### 全局最优性（Global Optimality）

在算法的最终结果中，不存在两个相邻块违反非降约束。如果能找到比该结果更优的解，那么那更优的解中必定有某种相邻子段的改进方式来降低成本，但 PAVA 已经通过反复合并确保在局部没有可改善的非降性冲突。实际上，这一步的正确性可用「交换证据法（exchange argument）」证明：如果有更优解，可以对比最终结果，若有差异可将该差异逐段「交换」回 PAVA 的过程中，引导出一个未曾处理的「相邻冲突」而与 PAVA 最终状态相矛盾。  

简单直观的说法：PAVA 通过一连串贪心式的「就地修正」来消灭所有非降违例，并在每次修正时把局部段的误差降到最低。最终没有剩余可优化的结构，说明全局已达最优。

#### **核心直觉**  

- 每个块代表一段连续元素，其赋值的点为这段的中位数，保证该段内部绝对偏差和最小。  
- 合并是为了解决单调性冲突，这种冲突显然得消除，否则解不可行。  
- 每次合并都只会让局部约束（非降性）问题更加完善，同时在局部保证最优性，最终经过有限次合并，整个序列都已达成非降且局部段误差都是最优的拼合结果。  
- 若最终还存在能改善的空间，则意味着合并尚未结束，和算法结束条件不符，故已是最优解。

综合起来，PAVA 算法因为在每个合并步骤中都执行了对冲突最有效的局部最优修正，并最终得到无冲突的全局可行解，因此是正确的，并且可以在线性时间内完成。

---
## 严格证明

下面给出 PAVA 算法正确性的一个较为形式化的证明思路。证明采用「交换论证（exchange argument）」和中位数的最优性来保证 PAVA 产生的解为全局最优。

### 问题描述  

我们要解决的问题是：给定序列 $C = (C_1, \ldots, C_n)$，求非降序列 $D = (D_1, \ldots, D_n)$ 使得  
$$
\sum_{i=1}^n |C_i - D_i|
$$
最小。

### PAVA 算法回顾

1. 初始时，将每个 $C_i$ 单独作为一个块(block)。
2. 从左到右扫描，当发现相邻块不满足单调性（即块的值不非降）时，合并这些块为一个更大的块。新块的值选为合并后所有元素的中位数，以最小化该块内部的绝对偏差和。
3. 重复合并，直至所有相邻块的值非降。

合并完成后，各块的值递增且每个块的值为该块包含的 $C_i$ 的中位数。令 $D^*$ 为 PAVA 算法产出的最终解。

### 要证明的内容

断言：$D^*$ 是原问题的最优解，即对任何满足非降性的其他解 $\hat{D}$ 有：  
$$
\sum_{i=1}^n |C_i - D^*_i| \leq \sum_{i=1}^n |C_i - \hat{D}_i|.
$$

### 关键性质与引理

1. **中位数的最优性**：  
   对任意一组数 $S = \{x_1,\ldots,x_m\}$，函数 $f(t) = \sum_{j=1}^m |x_j - t|$ 在 $t$ 为 $S$ 的中位数时达到最小值（若 $m$ 为偶数，中位数区间内任一点均可）。  

   直观来说，中位数将集合内的数分成两半，左边数不多于右边，从而绝对误差和最小。

2. **PAVA 合并块的操作保证局部最优**：  
   每次合并两个违反单调性的块，并将新块的值设为中位数时，都确保该新块的绝对偏差和最小。通过自左向右、必要时回溯合并的过程，最终没有相邻块出现值降序现象，从而得到可行的非降解。

### 交换论证

我们以反证法证明 $D^*$ 的全局最优性。设 $\hat{D}$ 是任意另一个可行解（满足非降性），假设  
$$
\sum_{i=1}^n |C_i - \hat{D}_i| < \sum_{i=1}^n |C_i - D^*_i|.
$$  
我们将展示这会导致矛盾。

1. **PAVA 解的分块结构**：  
   $D^*$ 是由 PAVA 得到的，它有一组不交叠的连续块 $I_1, I_2, \ldots, I_k$ （每个 $I_j = \{r_j, r_j+1, \ldots, s_j\}$ 是一段连续下标）。对每个块 $I_j$，$D^*$ 在这些位置上都取相同的值 $\theta_j$，且 $\theta_j$ 是 $\{C_i: i \in I_j\}$ 的中位数。

2. **比较 $\hat{D}$ 与 $D^*$**：  
   对于 PAVA 的每个块 $I_j$：  
   - $D^*$ 在该块内的误差为 $\sum_{i \in I_j}|C_i - \theta_j|$。  
   - $\hat{D}$ 在该块的误差为 $\sum_{i \in I_j}|C_i - \hat{D}_i|$。

   因为 $\theta_j$ 是该块中 $C_i$ 的中位数，所以对于该块的绝对误差和最优值不大于对任何其他统一值的误差和。特别地，如若 $\hat{D}$ 在 $I_j$ 内不是常数（即有内部变化）或选用的定值不同于 $\theta_j$，只会使得在 $I_j$ 的误差和不小于选择 $\theta_j$ 时的最优值。  

   若 $\hat{D}$ 在 $I_j$ 内与 $D^*$ 不同，我们可以「调整」$\hat{D}$ 在 $I_j$ 内的取值，将其所有 $\hat{D}_i$ 替换为 $\theta_j$，这样不会增加该块内的误差，甚至可能降低误差（因为中位数选择是最优的）。

3. **分块调整的可行性**：  
   将 $\hat{D}$ 在每个块 $I_j$ 内调整为常数 $\theta_j$。经过这一步调整后，得到一个新的序列 $\hat{D}'$：  
   - 对每个 $I_j$， $\hat{D}'_i = \theta_j$。  
   - 同时，$\hat{D}'$ 必然是非降序列吗？需要检查。但注意，$D^*$ 本身是非降的，各块的中位值 $\theta_j$ 不降序排列。  

   若调整后有违反单调性的现象，我们可以将相邻违反单调性的块合并，对合并后的大块重新取中位数值（这正是 PAVA 做法的逆向思考）。合并后绝对偏差和依然不会增加，因为重新选择中位数总是不会使误差和变大。

   重复合并直至无违反非降性的块结构。因为 $D^*$ 是最终的 PAVA 结构，可行且最优的块分法，我们最终将 $\hat{D}'$ 转化为与 $D^*$ 相同的解（同样的分块和同样的值），而在此过程中误差和没有增加。  

   由此可见，如果 $\hat{D}$ 有比 $D^*$ 更小的误差，我们也能通过上述步骤将 $\hat{D}$ 转化为 $D^*$ 的解（或与之等价的解），而不增加总误差。这意味着 $D^*$ 至少与 $\hat{D}$ 一样优，进而推翻了 $\hat{D}$ 更优的假设。

### 何时需要合并

当两个相邻块不违反单调性时，这两个块各自以其内部元素的中位数为值，已经在各自独立的子问题中达到了最优的绝对偏差和。**如果你在这种情况下强行将它们合并为一个更大块，那么合并后的大块也必须用大块所有元素的中位数来表示，这往往会使总偏差和上升或不变**，因为原先两个较小的中位数已经分别是各自子集最优的中心点。

只有在出现违反单调性的情况下，我们才「被迫」合并两个块。这是因为保持块独立存在会导致整体不满足非降约束，使得解不可行。此时，对相邻违例块进行合并并重新选择中位数是恢复可行性且尽量保持局部最优的唯一途径。

换句话说，合并操作本身并不一定带来更好的误差表现，只是解决单调性约束冲突的必要手段。当没有违例时，多余的合并不会给出更优解，反而可能带来更差的结果。
### **总结**

- 中位数选择确保局部块内部的绝对偏差和最优。  
- 对任意他解 $\hat{D}$，若它优于 $D^*$，则对 $\hat{D}$ 进行块内调整和相邻块合并操作（与 PAVA 的逆过程一致）可将其误差不增加地转化为 $D^*$。  
- 因此，不存在误差小于 $D^*$ 的另一个可行解，故 $D^*$ 是全局最优解。

这构成了 PAVA 算法正确性的正式论证。

# 算法实现

线性复杂度的算法实现极其困难（原因在于需要十分精巧的划分区间和重组，然后使用线性选择算法一次遍历），所以普遍来说是使用高效的数据结构来解决这类问题。（说实话，我从来没有见过有人使用严格意义上的线性复杂度的算法实现）

对于动态维护中位数和合并块，实际上最为合适的结构就是堆，而且左偏树具有可合并的性质，更加擅长此类问题，属于实践中的较好的解决方案。




