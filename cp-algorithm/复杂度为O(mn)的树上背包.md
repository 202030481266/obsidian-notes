
# [JSOI2016 最佳团体](https://www.luogu.com.cn/problem/P4322)

## 引言

在算法竞赛中，树上背包问题是一类经典且复杂的题目。本篇文章将详细解析最佳团体这道题目，着重讲解如何在树结构上进行动态规划，并实现时间复杂度为 $O(NK)$ 的算法。

## 题目描述

JSOI 信息学代表队共有 $N$ 名候选人，编号从 $1$ 到 $N$。为了方便，假设 JYY 的编号是 $0$。每个候选人都有一个编号比他小的推荐人 $R_i$。如果 $R_i = 0$，则说明该候选人是 JYY 自己看上的。

为了保证团队的和谐，JYY 需要确保：**如果招募了候选人 $i$，那么候选人 $R_i$ 也必须在团队中**。当然，JYY 自己总是在团队里的。

每个候选人有一个战斗值 $P_i$，以及一个招募费用 $S_i$。JYY 希望招募 $K$ 个候选人（不包括他自己），使得这 $K$ 个被选候选人的**总战斗值与总招募费用的比值最大**，即性价比最高。

### 输入格式

第一行包含两个正整数 $K$ 和 $N$。

接下来 $N$ 行，第 $i$ 行包含三个整数 $S_i$、$P_i$ 和 $R_i$，表示候选人 $i$ 的招募费用、战斗值和推荐人编号。

### 输出格式

输出一行一个实数，表示最佳比值。答案保留三位小数。

### 数据范围

- $1 \leq K \leq N \leq 2500$
- $0 < S_i, P_i \leq 10^4$
- $0 \leq R_i < i$

## 样例输入

```
1 2
1000 1 0
1 1000 1
```

## 样例输出

```
0.001
```

## 题目分析

### 关键观察

- **推荐关系构成了一棵树**：因为每个候选人都有一个编号比他小的推荐人，所以不会形成环，推荐关系天然形成一棵树。
- **选择依赖性**：如果选择了候选人 $i$，则必须选择其推荐人 $R_i$。这意味着如果选择了某个节点，必须选择其父节点。

### 转化目标

我们需要最大化总战斗值与总招募费用的比值，即：

$$
\text{最大化 } \frac{\sum P_i}{\sum S_i}
$$

为了方便计算，我们可以将比值最大化问题转化为判定性问题，即：

- 对于一个给定的比值 $x$，判断是否存在一个选择方案，使得：

$$
\sum (P_i - x \times S_i) \geq 0
$$

并且选择的候选人数为 $K$。

通过二分枚举 $x$ 的值，可以在一定精度范围内逼近最优解。

## 算法设计

### 二分答案

- **初始范围**：$x$ 的初始二分范围可以设定为 $[0, M]$，其中 $M$ 为一个足够大的数，例如 $10^4$。
- **判定过程**：在每次二分中，使用动态规划判断在当前 $x$ 下，是否能找到满足条件的方案。

### 树上动态规划

#### 状态定义

设 $dp[u][k]$ 表示在以节点 $u$ 为根的子树中，选择 $k$ 个节点所能获得的最大价值。其中价值定义为：

$$
\text{价值} = \sum (P_i - x \times S_i)
$$

#### 状态转移

- **初始化**：$dp[u][0] = 0$，表示不选择任何节点的价值为 $0$。
- **转移方程**：

  对于节点 $u$，需要考虑两种情况：

  1. **不选择节点 $u$**：由于题目要求，如果不选择节点 $u$，则其子节点也不能被选择。因此：
 $$
     dp[u][0] = 0
     $$

  2. **选择节点 $u$**：需要从子节点中选择若干个节点，组合成不同的方案。设子节点集合为 $\{v_1, v_2, \dots, v_m\}$，则： $$
     dp[u][k] = \max\left\{ \sum_{k_1 + k_2 + \dots + k_m = k - 1} \left( \sum_{i=1}^m dp[v_i][k_i] \right) + (P_u - x \times S_u) \right\}
     $$

其中，$k_i$ 表示在子节点 $v_i$ 的子树中选择的节点数。

#### 优化

- **复杂度分析**：直接进行上述状态转移的复杂度为 $O(NK^2)$，因为每个节点需要合并子节点的状态，且枚举 $k$ 的划分。
- **优化策略**：由于 $K$ 的范围与 $N$ 相同，可以接受 $O(NK)$ 的算法。我们可以采用类似**背包问题**的合并方式，使用滚动数组或其他优化技巧。

### 实现细节

- **DFS 序列化树**：将树转化为序列，方便线性地处理节点。
- **数组优化**：在 DP 中，我们可以倒序遍历 $k$，以避免数据的覆盖问题。

## 代码讲解

以下是实现上述算法的 C++ 代码，并附有详细注释。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2505;
int K, N, P[maxn], S[maxn], siz[maxn], dfn[maxn];
double dp[maxn][maxn]; 
vector<int> g[maxn];
int cnt = 0;

// 深度优先搜索，计算子树大小和节点顺序
void dfs(int u) {
    dfn[++cnt] = u;  // 记录节点的 DFS 序
    siz[u] = 1;      // 初始化子树大小
    for (int v : g[u]) {
        dfs(v);
        siz[u] += siz[v];  // 累加子树大小
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> K >> N;
    int fa;
    for (int i = 1; i <= N; ++i) {
        cin >> S[i] >> P[i] >> fa;
        g[fa].push_back(i);  // 建树
    }
    dfs(0);  // 从根节点开始 DFS

    double l = 0, r = 1e4;  // 二分初始范围
    for (int iter = 0; iter < 32; ++iter) {  // 二分 32 次，精度足够
        double mid = (l + r) / 2;
        // 初始化 dp 数组
        for (int i = 0; i <= N + 1; ++i) {
            fill(dp[i], dp[i] + K + 1, -1e18);
        }
        dp[N + 1][0] = 0;  // 边界条件

        // 从后往前 DP，按照 DFS 序列顺序
        for (int i = N; i >= 1; --i) {
            int u = dfn[i];
            // 不选择节点 u，跳过整个子树
            for (int j = 0; j <= K; ++j) {
                dp[i][j] = dp[i + siz[u]][j];
            }
            // 选择节点 u
            for (int j = 1; j <= K; ++j) {
                if (dp[i + 1][j - 1] != -1e18) {
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + P[u] - mid * S[u]);
                }
            }
        }
        // 判断是否有方案使得价值 >= 0
        if (dp[1][K] >= 0) l = mid;
        else r = mid;
    }
    cout << fixed << setprecision(3) << l << '\n';
    return 0;
}
```

### 代码说明

- **DFS 序列化树**：`dfs` 函数对树进行遍历，记录每个节点的 DFS 序 `dfn[]` 和子树大小 `siz[]`。
- **二分答案**：在主函数中，使用二分法寻找最优比值 `x`。
- **动态规划**：
  - `dp[i][j]` 表示从第 `i` 个节点开始，选择 `j` 个节点的最大价值。
  - 初始化时，所有值设为负无穷。
  - 从后往前 DP，按照 DFS 序列顺序。
  - **不选择节点 `u`**：`dp[i][j] = dp[i + siz[u]][j]`，跳过整个子树。
  - **选择节点 `u`**：`dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + P[u] - mid * S[u])`，处理当前节点并继续。

### 注意事项

- **精度处理**：由于涉及浮点数计算，二分次数应足够多，且输出时保留三位小数。
- **负无穷初始化**：为了避免与有效值混淆，初始化时应使用足够小的负数（如 `-1e18`）。

### DFN优化的本质原理

使用DFN优化的树形背包本质上就是将多重背包转换为了01背包。那么转换的方法就是从整体的树结构上来决定，而不是单独局限于一个经典的$u-v$树子结构。首先我们使用DFN序列化，倒序遍历，也就是满足后序的规则。然后，我们将树看成一个序列的方式进行01背包，然后决定要不要使用，如果使用当前节点，那么就可以随意选择之前的序列方案，如果不是那就要跳过当前的子树，在后面的不是子树中选择。

![[树形背包.svg]]
