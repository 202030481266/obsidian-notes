
# 初衷

公司的Web服务器没有显卡，但是内网有一台搭载A800的显卡服务器，难点在于内网不能公开访问，所以需要设计一个方法使得外网的主机能够访问到内网的显卡服务器。一个比较简单的方法就是用ssh加密隧道的方式进行通信，然后使用ssh反向代理和转发技术来搭建访问通道。

参考了师兄写的文章：[本地计算机上调用内网服务器的web服务](https://blog.csdn.net/qq_41101288/article/details/139562148)
一篇写的很好的博客：[我挖了一条网络隧道，差点被公司激活！](https://juejin.cn/post/7187336694880796733)

# 场景

假设本地主机是A，公网服务器是B，内网服务器是C，假设C在自己本地的8000端口开启了一个服务进程，那么A想通过自己的本地3000端口访问C的8000端口的服务。

![[ssh反向代理.svg#center]]

## SSH搭建反向代理

为了不想每一次使用IP地址访问主机，所以先可以在`~/.ssh/config`配置主机名，下面在C中配置好B的主机ssh配置文件：

```yaml
Host t1
	HostName B的IP
	User 登录B的用户名
	ServerAliveInterval 120
```

同样的，默认ssh访问我们不会使用密码，==一定要使用密钥来进行通信==！又快又方便又安全。

首先可以让B的2000端口代理C的22端口，这可以使用ssh的方向代理命令来实现：

```bash
ssh -R 2000:localhost:22 t1
```

至此，就可以成功通过以下命令访问C：

```bash
ssh root@localhost -p 2000
```

更加具体来说，当你通过跳板机B连接到`localhost:2000`端口时，跳板机B会将所有发送到`localhost:2000`的数据转发到内网服务器C的`localhost:22`（SSH端口）中。为什么使用反向代理？其实很简单，因为C可以访问B，但是B不能直接访问C，就是因为这个原因需要C主动建立代理SSH连接。

## 配置A访问到C

### 方法

既然B可以访问到C了，那么就可以通过B来访问C，其中B在这一个过程中担任了跳板机的角色。于是我们可以在A的Host文件中配置：

```yaml
Host t1 
	HostName B的IP 
	User 登录B的用户名 
	ServerAliveInterval 120 

Host c1 
	HostName localhost 
	User root 
	ProxyJump t1 
	ServerAliveInterval 120 
	Port 2000
```

然后在本地执行下面的ssh本地端口转发命令：

```bash
ssh -L 3000:localhost:8000 c1
```

最后测试一下是否能够访问成功（其实是一个大模型的服务）：

```bash
curl http://localhost:3000/v1/chat/completions -H "Content-Type: application/json" -d '{"model": "qwen", "messages": [{"role": "user", "content": "hello"}], "temperature": 0.7}'
```

好的，下面开始逐渐拆解这个过程。
### 环境设置

- **本地计算机A**：在这里发送请求到`localhost:3000`。
- **跳板机B**：作为代理，连接到内网服务器C。
- **内网服务器C**：提供服务，监听`localhost:8000`端口。

### 第一步：发送请求到本地端口3000

- 在本地计算机A上，你通过某种客户端（例如`curl`）发送HTTP请求到`localhost:3000`，这个请求以普通的TCP包形式开始，目标是A上的`localhost:3000`端口。

### 第二步：SSH隧道捕获请求

- 由于你已经运行了命令 `ssh -L 3000:localhost:8000 c1`，这条命令创建了一个本地端口转发（`-L`）的SSH隧道。它将本地计算机A的`localhost:3000`端口与内网服务器C的`localhost:8000`端口连接起来。
    
- 具体来说，SSH客户端会监听本地计算机A的`localhost:3000`端口。一旦接收到请求，SSH客户端会将这个请求“捕获”并加密传输到目标服务器。

### 第三步：SSH加密传输到跳板机B

- 本地计算机A捕获的请求通过已建立的SSH连接，首先被加密并传送到跳板机B。此时，跳板机B充当数据的中继站。
    
- 由于你在SSH配置文件中设置了`ProxyJump t1`，跳板机B自动将数据进一步传送到目标服务器C。

### 第四步：跳板机B将请求转发到内网服务器C

- 在跳板机B上，SSH隧道负责将本地计算机A的请求通过已建立的隧道转发到内网服务器C的`localhost:8000`端口。

### 第五步：内网服务器C的服务处理请求

- 内网服务器C接收到从`localhost:8000`端口到达的请求，并像处理本地请求一样对其进行处理。
- C上监听`localhost:8000`的服务（如一个API服务）读取HTTP请求，处理并生成响应。

### 第六步：将响应通过隧道返回

- 内网服务器C的服务生成响应，并将它发送到C的`localhost:8000`。
- SSH隧道捕获到这个响应数据，并通过跳板机B将响应加密并返回给本地计算机A。

### 第七步：本地计算机A解密并接收响应

- 本地计算机A的SSH客户端解密接收到的响应数据，并将它通过本地的`localhost:3000`端口返回给初始的请求发起者（例如，`curl`或浏览器）。
- 最终，`curl`客户端收到来自内网服务器C的响应。

### 流程总结：

1. 你在本地计算机A上发送请求到`localhost:3000`。
2. SSH隧道捕获请求并加密传输。
3. 请求经过跳板机B，被转发到内网服务器C的`localhost:8000`。
4. 内网服务器C处理请求，并将响应通过隧道返回。
5. 本地计算机A解密响应，并将它返回给请求发起者。

## 本地端口转发注意的点

- SSH 端口转发是通过 SSH 连接建立起来的，我们必须保持这个 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。
- 我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。（**只能同时创建，不可能增加**）
- 好了，我们已经在本地 建立了端口转发，那么既然我们在监听本地的9527端口，那么其他机器也访问本地的9523端口会不会自动转发呢？比如能否新增加一台客户端2来直接连接客户端的9527 端口？==答案是不行的，在主流 SSH 实现中，本地端口转发绑定的是 lookback 接口，这意味着只有 localhost 或者 127.0.0.1 才能使用本机的端口转发== , 其他机器发起的连接只会得到“ connection refused. ”。不过 SSH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。



