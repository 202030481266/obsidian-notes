首先重载两个函数：

```cpp
void* operator new(size_t size) {
	LOG("Allocating " << size << " bytes");
	return malloc(size);
}

void operator delete(void* memory, size_t size) {
	LOG("Deallocating " << size << " bytes");
	free(memory);
}
```

本质上，这些函数可以形成一种内存追踪器。

```cpp
#include "stdafx.h"
#define LOG(X) std::cout << X << std::endl


void* operator new(size_t size) {
	LOG("Allocating " << size << " bytes");
	return malloc(size);
}

void operator delete(void* memory, size_t size) {
	LOG("Deallocating " << size << " bytes");
	free(memory);
}

struct Edge {
	int u, v, w;
};


int main() {
	{
		Edge* e = new Edge();
		std::unique_ptr<Edge> ue = std::make_unique<Edge>();
		delete e;
	}
	return 0;
}
```

因此我们可以看到下面的输出：

```
Allocating 12 bytes
Allocating 12 bytes
Deallocating 12 bytes
Deallocating 12 bytes
```

我们也可以在对应的函数的位置打断点，从而更加深入地查看具体的内存分配机制。